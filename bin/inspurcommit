#!/bin/bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r old_change_history_name="Old$change_history_name"
declare -r fci_file_name="farewell-commit-id"

ShowUsage () {
    echo "Usage:
    inspurcommit [<operation>]$LF
Operations:
    amend, diff, export, exportall, init, push, template, usage$LF
For help on a specific operation:
    inspurcommit <operation> --help$LF
If no operation is specified, it is used to perform a git commit. Here are
the steps:
    1. Use command 'git add <file>', or 'git add .', etc. to stage changes.
    2. Write change history in file $tmpf.
       If this file does not exist, use command 'inspurcommit' to generate
       one, and then write change history in it.
    3. Use command 'inspurcommit' to commit. Arguments, if any, will be
       passed to git commit."
}

CheckInit () {
    if test ! -e "$fcif" || test ! -e "$tempf"
    then
        >&2 Prompt red \
            "ERROR: This repository haven't been initialized." \
            "Use command 'inspurcommit init --help' for help."
        return 1
    fi
    return 0
}

ValidateJgn () {
    which $jgn 1>/dev/null 2>&1 && return
    >&2 Prompt red "ERROR: Coundn't find $jgn."
    return 1
}

ValidateHistoryField () {
    local value=$(echo "$1" | grep "^$2:" | sed "s/^$2:\s*//")
    test "$value" && return
    >&2 Prompt red "ERROR: Field '$2' of change history is empty."
    return 1
}

ValidateHistory () {
    ValidateHistoryField "$1" 'Tag#' || exit
    ValidateHistoryField "$1" 'Label#' || exit
    ValidateHistoryField "$1" 'Issue#' || exit
    ValidateHistoryField "$1" 'Scope' || exit
    ValidateHistoryField "$1" 'Severity' || exit
    ValidateHistoryField "$1" 'Category' || exit
    ValidateHistoryField "$1" 'Symptom' || exit
    ValidateHistoryField "$1" 'RootCause' || exit
    ValidateHistoryField "$1" 'Solution' || exit
    ValidateHistoryField "$1" 'SolutionDependency' || exit
}

CheckStage () {
    case "$(git -c "core.safecrlf=false" diff --cached --name-only)" in
        "")
            test "$1" = "amend" && return 0
            >&2 Prompt red \
                "ERROR: There is no staged changes." \
                "Stage changes to be committed with 'git add'."
            return 1
            ;;
        *"$tempf"*)
            test "$1" = "template" && return 0
            git restore --staged "$tempf" > /dev/null
            >&2 Prompt yellow \
                "Warning: $tempf was staged. But was skipped." \
                "If you intend to modify the template, use command 'inspurcommit template'."
            CheckStage
            ;;
    esac
}

CheckFileAlreadyExists () {
    local filename="$1"
    test -e "$filename" || return 0
    >&2 Prompt red "ERROR: File $filename already exists."
    return 1
}

FindFile () {
    local filename="$1"
    test -e "$filename" && return 0
    >&2 Prompt red "ERROR: Couldn't find file $filename."
    return 1
}

Commit () {
    local tmpc
    local jgnc
    local summary
    local details
    local lastslt
    local chid
    tmpc=$(cat "$tmpf" | grep -v '^#\|^\s*$')
    ValidateHistory "$tmpc"
    summary=$(echo "$tmpc" | grep '^Solution:' | sed 's/^Solution:\s*//')
    if test ! "$op" = "amend"
    then
        lastslt=$(git log -1 --format=%s)
        if test "$lastslt" = "$summary"
        then
            >&2 Prompt red "ERROR: Solution is same with last one."
            return 1
        fi
    fi
    if ValidateHistoryField "$tmpc" "RelatedFiles" 2>/dev/null
    then
        tmpc=$(echo "$tmpc" | sed '/^RelatedFiles:/,$d')
        ValidateJgn || exit
        if test "$op" = "amend"
        then
            git reset --soft @^ || exit
            jgnc=$($jgn)
            git reset --soft ORIG_HEAD
        else
            jgnc=$($jgn)
        fi
        tmpc="$tmpc$LF$jgnc"
    fi
    details="$tmpc"
    if test "$op" = "amend"
    then
        chid=$(git log -1 --format=%b | grep '^Change-Id:')
        test "$chid" ||
            >&2 Prompt yellow "Warning: Failed to get Change-ID."
        git commit "$@" -m "$summary" -m "$details" -m "$chid"
    else
        git commit "$@" -m "$summary" -m "$details"
    fi
}

# Export a Change History
# $1: exclude-field: 'none', 'Scope'.
# $2: [ filename ]: Use "ChangeHistory[-All]-%h" if not specified.
Export () {
    local currhash
    local chfn
    local fci
    local fcic
    local mode
    local ch_content
    CheckInit || return
    fci=$(cat "$fcif")
    fcic=$(git rev-list --reverse "$fci"..@ | head -1)
    if test "$1" = "none" || test ! "$1"
    then
        mode="all"
        ch_content=$(git log "$fcic".. --format="%b" | sed '/^Change-Id:\s\w\{41\}$/,+1d')
    else
        mode="notall"
        ch_content=$(git log "$fcic".. --format="%b" | grep -v "^$1:" | sed '/^Change-Id:\s\w\{41\}$/,+1d')
    fi
    if test ! "$ch_content"
    then
        >&2 Prompt red "ERROR: Nothing to export."
        return 1
    fi
    currhash=$(git log -1 --format='%h')
    case "$mode" in
        "all")
            chfn=${2:-"ChangeHistory-All-${currhash}.txt"}
            ;;
        "notall")
            chfn=${2:-"ChangeHistory-${currhash}.txt"}
            ;;
        *)
            >&2 echo "ERROR: Export mode is neither all nor notall."
            exit 1
            ;;
    esac
    CheckFileAlreadyExists "$chfn" || return
    echo "$ch_content" > "$chfn"
    FindFile "$oldf" 2>/dev/null &&
        d2u "$oldf" 2>/dev/null &&
        echo "$LF$(cat "$oldf")" >> "$chfn"
    Prompt green "Exported file $chfn"
    return
}

#  $1:  switch
#  $2:  argument
# &$3:  variable
InitParseArg () {
    if test ! "$2"
    then
        >&2 Prompt red "ERROR: '$1' requires a value."
        exit 1
    fi
    local -n var=$3
    var="$2"
}

InitTemplate () {
    local dff=$(dirname "$0")/"$tempf"
    local dfc
    FindFile "$dff" || return 1
    dfc=$(cat "$dff")
    test "$dfTag" && dfc=$(echo "$dfc" |
        sed "s/^Tag#:.*$/Tag#: $dfTag/")
    test "$dfLbl" && dfc=$(echo "$dfc" |
        sed "s/^Label#:.*$/Label#: $dfLbl/")
    test "$dfIss" && dfc=$(echo "$dfc" |
        sed "s/^Issue#:.*$/Issue#: $dfIss/")
    test "$dfScp" && dfc=$(echo "$dfc" |
        sed "s/^Scope:.*$/Scope: $dfScp/")
    test "$dfSvr" && dfc=$(echo "$dfc" |
        sed "s/^Severity:.*$/Severity: $dfSvr/")
    test "$dfCtg" && dfc=$(echo "$dfc" |
        sed "s/^Category:.*$/Category: $dfCtg/")
    test "$dfSpt" && dfc=$(echo "$dfc" |
        sed "s/^Symptom:.*$/Symptom: $dfSpt/")
    test "$dfRtc" && dfc=$(echo "$dfc" |
        sed "s/^RootCause:.*$/RootCause: $dfRtc/")
    test "$dfSlt" && dfc=$(echo "$dfc" |
        sed "s/^Solution:.*$/Solution: $dfSlt/")
    test "$dfDpd" && dfc=$(echo "$dfc" |
        sed "s/^SolutionDependency:.*$/SolutionDependency: $dfDpd/")
    test "$dfRlf" && dfc=$(echo "$dfc" |
        sed "s/^RelatedFiles:.*$/RelatedFiles: $dfRlf/")
    echo "$dfc" > "$tempf"
}

GenerateTmp () {
    FindFile "$tmpf" 2>/dev/null && return
    cp ./"$tempf" ./"$tmpf"
    Prompt green "Generated file $tmpf"
    Prompt yellow \
        "Write change history in this file and save, and commit again."
    return 1
}

pushUsage () {
    echo "Usage:
    inspurcommit push [<branch>]$LF
Push local commits to Gerrit. By default, <branch> is 'master'.
This command is equivalent to:$LF
    git push origin HEAD:refs/for/<branch>"
}

amendUsage () {
    echo "Usage:
    inspurcommit amend [<options>]$LF
Amend last commit with current $tmpf and staged changes.
<options> will be passed to git commit. "
}

exportUsage () {
    echo "Usage:
    inspurcommit export [<filename>]
    inspurcommit exportall [<filename>]$LF
Export a change history.
If 'export' is used, will filter out 'scope'."
}

templateUsage () {
    echo "Usage:
    inspurcommit template [<options>]$LF
Normally, changes of the template cannot be committed, in case it is
changed by accident. When you intend to change the template, you can use
this operation.
<options> will be passed to git commit."
}

initUsage () {
    echo "Usage:
    inspurcommit init [<defaults>]$LF
Defaults:
    -t, --tag <tag#>
    -l, --label <label#>
    -i, --issue <Issue#>
    -s, --scope <Scope>
    -v, --severity <Severity>
    -c, --category <Category>
    -y, --symptom <Symptom>
    -r, --rootcause <RootCause>
    -o, --solution <Solution>
    -d, --dependency <SolutionDependency>
    -f, --files <RelatedFiles>$LF
Example:
    inspurcommit init -t \"5.19_CedarIslandCrb_0ACMT_013\""
}

diffUsage () {
    echo "Usage:
    inspurcommit diff [<option>...]$LF
Diff with Beyond Compare. <Option>, if any, will be passed to git difftool.
Try 'git difftool --help' for more information.$LF
If you want to diff the staged changes, use 'inspurcommit diff --cached'."
}

LookupUsage () {
    test "$2" || return 0
    case "$2" in
        "-?"|"-h"|"--help"|"--usage")
            ${1}Usage
            return 1
            ;;
    esac
    return 0
}

# Prompt
# $1:   color, red/yellow/green
# ...:  content lines
Prompt () {
    local -r red="[91m"
    local -r grn="[92m"
    local -r ylw="[93m"
    local -r reset="[0m"
    local -r color_arg="$1"
    local color
    shift
    case "$color_arg" in
        r|red)
            color="$red"
            ;;
        g|grn|green)
            color="$grn"
            ;;
        y|ylw|yellow)
            color="$ylw"
            ;;
        *)
            Prompt red "ERROR: Unknown color argument - ${color_arg}"
            return 1
            ;;
    esac
    printf "${color}%s${reset}\n" "$@"
}

declare -r rev='0.4.2'
declare -r lastupdt='2021-07-30'
declare -r author='Johnny Appleseed <liuzhaohui@inspur.com>'
declare -r jgn="jgnumberforthehistory"
declare -r tempf="$template_file_name"
declare -r tmpf="$change_history_name"
declare -r oldf="$old_change_history_name"
declare -r fcif="$fci_file_name"
declare -r LF='
'

declare -r op="${1,,}"
case "$op" in
    "?"|"-?"|"-h"|"--help"|"--usage"|"help"|"usage")
        echo
        echo "    inspurcommit v$rev"
        echo "    Last updated: $lastupdt"
        echo "    $author"
        echo
        ShowUsage
        exit
        ;;

    ""|"-"*)
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage || exit
        Commit "$@"
        ;;

    "push")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        p_br="${1:-master}"
        shift
        git push origin HEAD:refs/for/"$p_br" "$@"
        exit
        ;;

    "diff")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        bcomp="$(reg query "HKCU\\Software\\Scooter Software\\Beyond Compare" //v "ExePath" 2>/dev/null)"
        if test ! "$bcomp"
        then
            >&2 Prompt red "ERROR: Couldn't find Beyond Compare."
            exit 1
        fi
        bcomp="$(echo "$bcomp" | grep "ExePath" | sed 's/\s\{4\}.*\s\{4\}//')"
        git -c "diff.tool=BeyondCompare" \
            -c "difftool.BeyondCompare.cmd=\"${bcomp}\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\"" \
            difftool --dir-diff "$@"
        ;;

    "amend")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage amend || exit
        Commit --amend "$@"
        ;;

    "export")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        Export "Scope" "$@"
        ;;

    "exportall")
        shift
        LookupUsage "export" "$@" || exit 0
        git rev-parse || exit
        Export "none" "$@"
        ;;

    "template")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage template || exit
        Commit "$@"
        ;;

    "init")
        shift
        while test $# -gt 0
        do
            case "${1,,}" in
                -t|--tag)
                    InitParseArg "$1" "$2" dfTag
                    shift 2
                    ;;
                -l|--label)
                    InitParseArg "$1" "$2" dfLbl
                    shift 2
                    ;;
                -i|--issue)
                    InitParseArg "$1" "$2" dfIss
                    shift 2
                    ;;
                -s|--scope)
                    InitParseArg "$1" "$2" dfScp
                    shift 2
                    ;;
                -v|--severity)
                    InitParseArg "$1" "$2" dfSvr
                    shift 2
                    ;;
                -c|--category)
                    InitParseArg "$1" "$2" dfCtg
                    shift 2
                    ;;
                -y|--symptom)
                    InitParseArg "$1" "$2" dfSpt
                    shift 2
                    ;;
                -r|--rootcause)
                    InitParseArg "$1" "$2" dfRtc
                    shift 2
                    ;;
                -o|--solution)
                    InitParseArg "$1" "$2" dfSlt
                    shift 2
                    ;;
                -d|--dependency|--solution-dependency)
                    InitParseArg "$1" "$2" dfDpd
                    shift 2
                    ;;
                -f|--files|--related-files)
                    InitParseArg "$1" "$2" dfRlf
                    shift 2
                    ;;
                '-?'|-h|--help|--usage)
                    initUsage
                    exit
                    ;;
                *)
                    >&2 Prompt red "ERROR: invalid argument - $1"
                    >&2 initUsage
                    exit 1
                    ;;
            esac
        done
        git rev-parse || exit
        if test ! -e ./.git
        then
            >&2 Prompt red "ERROR: Please init in the root directory."
            exit 1
        fi
        if CheckInit 2>/dev/null
        then
            >&2 Prompt red \
                "ERROR: This repository has already been initialized."
            exit 1
        fi
        case "$(git status --porcelain)" in
            *".gitignore"*)
                >&2 Prompt red "ERROR: Please commit or stash your local changes of file '.gitignore'" "before init."
                exit 1
                ;;
        esac
        if CheckStage 2>/dev/null
        then
            >&2 Prompt red "ERROR: Please commit or stash your staged changes before init."
            >&2 git status
            exit 1
        fi
        test -e "$tmpf" &&
            (d2u "$tmpf" 2>/dev/null || exit) &&
            (mv "$tmpf" "Old$tmpf" || exit) &&
            (git -c "core.safecrlf=false" add "$tmpf" "Old$tmpf" || exit)
        git log --format="%H" -1 > "$fcif" &&
            InitTemplate &&
            echo "/$tmpf" >> .gitignore &&
            echo "/ChangeHistory-*.txt" >> .gitignore &&
            git -c "core.safecrlf=false" add "$tempf" "$fcif" .gitignore &&
            git commit -m "INSPURCOMMIT-INIT" -m "
This commit was automatically generated to initialize this repository in
order to use Inspur Commit Kit." 1>/dev/null &&
            Prompt green "Initialization completed successfully."
        ;;
    *)
        >&2 Prompt red "ERROR: Invalid option - $1"
        >&2 ShowUsage
        exit 1
        ;;
esac
