#!/bin/bash
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r old_change_history_name="Old$change_history_name"
declare -r fci_file_name="farewell-commit-id"

CheckInit () {
    if test ! -e "$fcif" || test ! -e "$tempf"
    then
        >&2 Prompt red \
            "ERROR: This repository haven't been initialized." \
            "Use command 'inspurcommit init --help' for help."
        return 1
    fi
    return 0
}

ValidateJgn () {
    type "$jgn" 1>/dev/null 2>&1 && return
    >&2 Prompt red "ERROR: Coundn't find $jgn."
    return 1
}

ValidateHistoryField () {
    local value
    local content
    local field
    test "$#" -eq 2 || return
    content="$1"
    field="$2"
    value=$(printf "%s\n" "$content" |
        grep "^${field}:" |
        sed "s/^${field}:\s*//")
    test "$value" && return
    >&2 Prompt red "ERROR: Field '$field' of change history is empty."
    return 1
}

ValidateHistory () {
    local content
    test "$#" -eq 1 || return
    content="$1"
    ValidateHistoryField "$content" 'Tag#' || exit
    ValidateHistoryField "$content" 'Label#' || exit
    ValidateHistoryField "$content" 'Issue#' || exit
    ValidateHistoryField "$content" 'Scope' || exit
    ValidateHistoryField "$content" 'Severity' || exit
    ValidateHistoryField "$content" 'Category' || exit
    ValidateHistoryField "$content" 'Symptom' || exit
    ValidateHistoryField "$content" 'RootCause' || exit
    ValidateHistoryField "$content" 'Solution' || exit
    ValidateHistoryField "$content" 'SolutionDependency' || exit
}

CheckStage () {
    local option="normal"
    test "$#" -ge 1 && option="$1"
    case "$(git -c "core.safecrlf=false" diff --cached --name-only)" in
        "")
            test "$option" = "amend" && return 0
            >&2 Prompt red \
                "ERROR: There is no staged changes." \
                "Stage changes to be committed with 'git add'."
            return 1
            ;;
        *"$tempf"*)
            test "$option" = "template" && return 0
            git restore --staged "$tempf" >/dev/null
            >&2 Prompt yellow \
                "Warning: $tempf was staged. But was skipped." \
                "If you intend to modify the template, use command 'inspurcommit template'."
            CheckStage
            ;;
    esac
}

CheckFileAlreadyExists () {
    local filename
    test "$#" -eq 1 && filename="$1" || return
    test ! -e "$filename" && return
    >&2 Prompt red "ERROR: File $filename already exists."
    return 1
}

FindFile () {
    local filename
    test "$#" -eq 1 && filename="$1" || return
    test -e "$filename" && return
    >&2 Prompt red "ERROR: Couldn't find file $filename."
    return 1
}

Commit () {
    local tmpc
    local jgnc
    local summary
    local details
    local lastslt
    local chid
    tmpc=$(grep -v '^#\|^\s*$' <"$tmpf")
    ValidateHistory "$tmpc"
    summary=$(printf "%s\n" "$tmpc" |
        grep '^Solution:' |
        sed 's/^Solution:\s*//')
    if test ! "$op" = "amend"
    then
        lastslt=$(git log -1 --format=%s)
        if test "$lastslt" = "$summary"
        then
            >&2 Prompt red "ERROR: Solution is same with last one."
            return 1
        fi
    fi
    if ValidateHistoryField "$tmpc" "RelatedFiles" 2>/dev/null
    then
        tmpc=$(printf "%s\n" "$tmpc" | sed '/^RelatedFiles:/,$d')
        ValidateJgn || exit
        if test "$op" = "amend"
        then
            git reset --soft @^ || exit
            jgnc=$("$jgn")
            git reset --soft ORIG_HEAD
        else
            jgnc=$("$jgn")
        fi
        printf -v tmpc "%s\n%s" "$tmpc" "$jgnc"
    fi
    details="$tmpc"
    if test "$op" = "amend"
    then
        chid=$(git log -1 --format=%b | grep '^Change-Id:')
        test "$chid" ||
            >&2 Prompt yellow "Warning: Failed to get Change-ID."
        git commit "$@" -m "$summary" -m "$details" -m "$chid"
    else
        git commit "$@" -m "$summary" -m "$details"
    fi
}

# Export a Change History
# $1: exclude-field: 'none', 'Scope'.
# $2: [ filename ]: Use "ChangeHistory[-All]-%h" if not specified.
Export () {
    local -r filter="$1"
    local chfn
    local currhash
    local fci
    local fcic
    local ch_content
    CheckInit || return
    test "$#" -ge 2 && chfn="$2"
    fci=$(<"$fcif")
    fcic=$(git rev-list --reverse "$fci".. | head -1)
    if test ! "$fcic"
    then
        >&2 Prompt red "ERROR: Nothing to export."
        return 1
    fi
    if test "$filter" = "none"
    then
        ch_content=$(git log --format=%b "$fcic".. |
            sed '/^Change-Id:\s\w\{41\}$/,+1d')
    else
        ch_content=$(git log --format=%b "$fcic".. |
            grep -v "^${filter}:" |
            sed '/^Change-Id:\s\w\{41\}$/,+1d')
    fi
    if test ! "$ch_content"
    then
        >&2 Prompt red "ERROR: Nothing to export."
        return 1
    fi
    currhash=$(git log -1 --format=%h)
    if test "$filter" = "none"
    then
        chfn=${chfn:-"ChangeHistory-All-${currhash}.txt"}
    else
        chfn=${chfn:-"ChangeHistory-${currhash}.txt"}
    fi
    CheckFileAlreadyExists "$chfn" || return
    printf "%s\n" "$ch_content" >"$chfn"
    FindFile "$oldf" 2>/dev/null &&
        d2u "$oldf" 2>/dev/null &&
        printf "\n%s" "$(<"$oldf")" >>"$chfn"
    Prompt green "Exported file $chfn"
}

#  $1:  switch
#  $2:  argument
# &$3:  variable
InitParseArg () {
    local -n var=$3
    var="$2"
}

InitTemplate () {
    local dff
    local dfc
    dff="$(dirname "$0")/$tempf"
    FindFile "$dff" || return 1
    dfc=$(<"$dff")
    test "${dfTag:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Tag#:.*$/Tag#: $dfTag/")
    test "${dfLbl:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Label#:.*$/Label#: $dfLbl/")
    test "${dfIss:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Issue#:.*$/Issue#: $dfIss/")
    test "${dfScp:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Scope:.*$/Scope: $dfScp/")
    test "${dfSvr:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Severity:.*$/Severity: $dfSvr/")
    test "${dfCtg:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Category:.*$/Category: $dfCtg/")
    test "${dfSpt:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Symptom:.*$/Symptom: $dfSpt/")
    test "${dfRtc:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^RootCause:.*$/RootCause: $dfRtc/")
    test "${dfSlt:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^Solution:.*$/Solution: $dfSlt/")
    test "${dfDpd:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^SolutionDependency:.*$/SolutionDependency: $dfDpd/")
    test "${dfRlf:-}" && dfc=$(printf "%s\n" "$dfc" |
        sed "s/^RelatedFiles:.*$/RelatedFiles: $dfRlf/")
    printf "%s\n" "$dfc" >"$tempf"
}

GenerateTmp () {
    FindFile "$tmpf" 2>/dev/null && return
    cp "./$tempf" "./$tmpf"
    Prompt green "Generated file $tmpf"
    Prompt yellow \
        "Write change history in this file and save, and commit again."
    return 1
}

ShowUsage () {
cat <<\SHOWUSG
Usage:
    inspurcommit [<operation>]

Operations:
    amend, diff, export, exportall, init, push, template, usage

For help on a specific operation:
    inspurcommit <operation> --help

If no operation is specified, it is used to perform a git commit. Here are
the steps:
    1. Use command 'git add <file>', or 'git add .', etc. to stage changes.
    2. Write change history in file $tmpf.
       If this file does not exist, use command 'inspurcommit' to generate
       one, and then write change history in it.
    3. Use command 'inspurcommit' to commit. Arguments, if any, will be
       passed to git commit.
SHOWUSG
}

pushUsage () {
cat <<\PUSHUSG
Usage:
    inspurcommit push [<branch>]

Push local commits to Gerrit. Default <branch> is 'master'. This command
is equivalent to:

    git push origin HEAD:refs/for/<branch>
PUSHUSG
}

amendUsage () {
cat <<\AMENDUSG
Usage:
    inspurcommit amend [<options>]

Amend last commit with current $tmpf and staged changes. <Options> will be
passed to git commit.
AMENDUSG
}

exportUsage () {
cat <<\EXPORTUSG
Usage:
    inspurcommit export [<filename>]
    inspurcommit exportall [<filename>]

Export a change history. If 'export', instead of 'exportall', is used, will
filter out 'scope'.
EXPORTUSG
}

templateUsage () {
cat <<\TEMPLATEUSG
Usage:
    inspurcommit template [<options>]

Normally, changes of the template cannot be committed, in case it is
changed by accident. When you intend to change the template, you can use
this operation. <Options> will be passed to git commit.
TEMPLATEUSG
}

initUsage () {
cat <<\INITUSG
Usage:
    inspurcommit init [<defaults>]

Defaults:
    -t, --tag <tag#>
    -l, --label <label#>
    -i, --issue <Issue#>
    -s, --scope <Scope>
    -v, --severity <Severity>
    -c, --category <Category>
    -y, --symptom <Symptom>
    -r, --rootcause <RootCause>
    -o, --solution <Solution>
    -d, --dependency <SolutionDependency>
    -f, --files <RelatedFiles>

Example:
    inspurcommit init -t "5.19_CedarIslandCrb_0ACMT_013"
INITUSG
}

diffUsage () {
cat <<\DIFFUSG
Usage:
    inspurcommit diff [<option>...]

Diff with Beyond Compare. <Option>, if any, will be passed to git difftool.
Try 'git difftool --help' for more information.

If you want to diff the staged changes, use 'inspurcommit diff --cached'.
DIFFUSG
}

LookupUsage () {
    local -r operation="$1"
    local argument
    test "$#" -le 1 && return
    argument="$2"
    if test "$argument" = "-?" ||
        test "$argument" = "-h" ||
        test "$argument" = "--help" ||
        test "$argument" = "--usage"
    then
            ${operation}Usage
            return 1
    fi
    return 0
}

# Prompt
# $1:   color, red/yellow/green
# ...:  content lines
Prompt () {
    local -r red="[91m"
    local -r grn="[92m"
    local -r ylw="[93m"
    local -r reset="[0m"
    local -r color_arg="$1"
    local color
    shift
    case "$color_arg" in
        r|red)
            color="$red"
            ;;
        g|grn|green)
            color="$grn"
            ;;
        y|ylw|yellow)
            color="$ylw"
            ;;
        *)
            Prompt red "ERROR: Unknown color argument - ${color_arg}"
            return 1
            ;;
    esac
    printf "${color}%s${reset}\n" "$@"
}

declare -r rev='0.4.2'
declare -r lastupdt='2021-07-30'
declare -r author='Johnny Appleseed <liuzhaohui@inspur.com>'
declare -r jgn="jgnumberforthehistory"
declare -r tempf="$template_file_name"
declare -r tmpf="$change_history_name"
declare -r oldf="$old_change_history_name"
declare -r fcif="$fci_file_name"

test "$#" -ge 1 && op="${1,,}" || op=""
if test "$op" && {
    test "$op" = "-?" ||
    test "$op" = "-h" ||
    test "$op" = "--help" ||
    test "$op" = "--usage" ||
    test "$op" = "help" ||
    test "$op" = "usage"; }
then
    printf "%s\n" \
        "" \
        "    inspurcommit v$rev" \
        "    Last updated: $lastupdt" \
        "    $author" \
        ""
    ShowUsage
    exit
fi
if test ! "$op" || { printf "%s" "$op" | grep -q "^-"; }
then
    git rev-parse || exit
    CheckInit || exit
    GenerateTmp || exit 0
    CheckStage || exit
    Commit "$@"
    exit
fi
shift
case "$op" in
    push)
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        if test "$#" -lt 1
        then
            p_br="master"
        elif test "$#" -eq 1
        then
            p_br="$1"
        else
            >&2 Prompt red "ERROR: Too many arguments."
            exit 1
        fi
        git push origin HEAD:refs/for/"$p_br" "$@"
        exit
        ;;

    diff)
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        bcomp=$(reg query "HKCU\\Software\\Scooter Software\\Beyond Compare" //v "ExePath" 2>/dev/null)
        if test ! "$bcomp"
        then
            >&2 Prompt red "ERROR: Couldn't find Beyond Compare."
            exit 1
        fi
        bcomp=$(printf "%s\n" "$bcomp" |
            grep "ExePath" |
            sed 's/\s\{4\}.*\s\{4\}//')
        git -c "diff.tool=BeyondCompare" \
            -c "difftool.BeyondCompare.cmd=\"${bcomp}\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\"" \
            difftool --dir-diff "$@"
        ;;

    amend)
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage amend || exit
        Commit --amend "$@"
        ;;

    export)
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        Export "Scope" "$@"
        ;;

    exportall)
        LookupUsage "export" "$@" || exit 0
        git rev-parse || exit
        Export "none" "$@"
        ;;

    template)
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage template || exit
        Commit "$@"
        ;;

    init)
        LookupUsage "$op" "$@" || exit 0
        while test "$#" -gt 0
        do
            init_sw="${1,,}"
            if test "$#" -ge 2
            then
                init_val="$2"
            else
                Prompt red "ERROR: $init_sw requires a value."
                exit 1
            fi
            case "$init_sw" in
                -t|--tag)
                    InitParseArg "$init_sw" "$init_val" dfTag
                    shift 2
                    ;;
                -l|--label)
                    InitParseArg "$init_sw" "$init_val" dfLbl
                    shift 2
                    ;;
                -i|--issue)
                    InitParseArg "$init_sw" "$init_val" dfIss
                    shift 2
                    ;;
                -s|--scope)
                    InitParseArg "$init_sw" "$init_val" dfScp
                    shift 2
                    ;;
                -v|--severity)
                    InitParseArg "$init_sw" "$init_val" dfSvr
                    shift 2
                    ;;
                -c|--category)
                    InitParseArg "$init_sw" "$init_val" dfCtg
                    shift 2
                    ;;
                -y|--symptom)
                    InitParseArg "$init_sw" "$init_val" dfSpt
                    shift 2
                    ;;
                -r|--rootcause)
                    InitParseArg "$init_sw" "$init_val" dfRtc
                    shift 2
                    ;;
                -o|--solution)
                    InitParseArg "$init_sw" "$init_val" dfSlt
                    shift 2
                    ;;
                -d|--dependency|--solution-dependency)
                    InitParseArg "$init_sw" "$init_val" dfDpd
                    shift 2
                    ;;
                -f|--files|--related-files)
                    InitParseArg "$init_sw" "$init_val" dfRlf
                    shift 2
                    ;;
                *)
                    >&2 Prompt red "ERROR: invalid argument - $init_sw"
                    >&2 initUsage
                    exit 1
                    ;;
            esac
        done
        git rev-parse || exit
        if test ! -e ./.git
        then
            >&2 Prompt red "ERROR: Please init in the root directory."
            exit 1
        fi
        if CheckInit 2>/dev/null
        then
            >&2 Prompt red \
                "ERROR: This repository has already been initialized."
            exit 1
        fi
        case "$(git status --porcelain)" in
            *".gitignore"*)
                >&2 Prompt red "ERROR: Please commit or stash your local changes of file '.gitignore'" "before init."
                exit 1
                ;;
        esac
        if CheckStage 2>/dev/null
        then
            >&2 Prompt red "ERROR: Please commit or stash your staged changes before init."
            >&2 git status
            exit 1
        fi
        test -e "$tmpf" &&
            { d2u "$tmpf" 2>/dev/null || exit; } &&
            { mv "$tmpf" "Old$tmpf" || exit; } &&
            { git -c "core.safecrlf=false" \
                add "$tmpf" "Old$tmpf" || exit; }
        git log --format="%H" -1 >"$fcif" &&
            InitTemplate &&
            printf "%s\n" "/$tmpf" >>.gitignore &&
            printf "%s\n" "/ChangeHistory-*.txt" >>.gitignore &&
            git -c "core.safecrlf=false" add "$tempf" "$fcif" .gitignore &&
            printf -v init_msg "%s\n" \
            "This commit was automatically generated to initialize this repository in" \
            "order to use Inspur Commit Kit." &&
            git commit -m "INSPURCOMMIT-INIT" -m "$init_msg" 1>/dev/null &&
            Prompt green "Initialization completed successfully."
        ;;
    *)
        >&2 Prompt red "ERROR: Invalid option - $op"
        >&2 ShowUsage
        exit 1
        ;;
esac
