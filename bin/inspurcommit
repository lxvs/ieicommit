#!/bin/bash
set -o nounset   # abort on unbound variable

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r old_change_history_name="Old$change_history_name"
declare -r fci_file_name="farewell-commit-id"

pushd () {
    command pushd "$@" 1>/dev/null
}

popd () {
    command popd "$@" 1>/dev/null
}

CheckInit () {
    PushdRoot
    test -e "$FCIF" && test -e "$TEMPF" && popd && return
    >&2 Prompt red \
        "ERROR: This repository haven't been initialized." \
        "Use command 'inspurcommit init --help' for help."
    popd
    return 1
}

ValidateJgn () {
    type "$JGN" 1>/dev/null 2>&1 && return
    >&2 Prompt red "ERROR: Coundn't find $JGN."
    return 1
}

ValidateHistoryField () {
    local value
    local content="$1"
    local field="$2"
    GetField value "$content" "$field"
    test "${value-}" && return
    >&2 Prompt red "ERROR: Field '$field' of change history is empty."
    return 1
}

ValidateHistory () {
    local content="$1"
    ValidateHistoryField "$content" 'Tag#' || return
    ValidateHistoryField "$content" 'Label#' || return
    ValidateHistoryField "$content" 'Issue#' || return
    ValidateHistoryField "$content" 'Scope' || return
    ValidateHistoryField "$content" 'Severity' || return
    ValidateHistoryField "$content" 'Category' || return
    ValidateHistoryField "$content" 'Symptom' || return
    ValidateHistoryField "$content" 'RootCause' || return
    ValidateHistoryField "$content" 'Solution' || return
    ValidateHistoryField "$content" 'SolutionDependency' || return
}

CheckStage () {
    local option="${1-normal}"
    local -r DIFF=$(git -c "core.safecrlf=false" diff --cached --name-only)
    test "$DIFF" || CheckStage_NoStage || return
    grep -q "\<$TEMPF\>" <<<"$DIFF" || return 0
    CheckStage_HasTemp
}

CheckStage_NoStage () {
    test "$option" = "amend" && return
    >&2 Prompt red \
        "ERROR: There is no staged changes." \
        "Stage changes to be committed with 'git add'."
    return 1
}

CheckStage_HasTemp () {
    test "$option" = "template" && return
    git restore --staged "$TEMPF" >/dev/null
    >&2 Prompt yellow \
"Warning: $TEMPF was staged. But was skipped." \
"If you want to modify the template, use command 'inspurcommit template'."
    CheckStage
}

CheckFileAlreadyExists () {
    local filename="$1"
    test ! -e "$filename" && return
    >&2 Prompt red "ERROR: File $filename already exists."
    return 1
}

FindFile () {
    local filename="$1"
    test -e "$filename" && return
    >&2 Prompt red "ERROR: Couldn't find file $filename."
    return 1
}

# Get Field Content
# & $1: variable byref
#   $2: change history content
#   $3: field
GetField () {
    local -n gf_var=$1
    local -r CHC="$2"
    local -r FIELD="$3"
    gf_var=$(grep "^${FIELD}:" <<<"$CHC" | sed "s/^${FIELD}:\s*//")
}

# Set Field Content
# & $1: change history content byref
#   $2: field
#   $3: field content
SetField () {
    local -n chc=$1
    local -r SF_FLD="$2"
    local -r SF_FLDC="$3"
    chc=$(sed "s/^${SF_FLD}:.*$/${SF_FLD}: ${SF_FLDC}/" <<<"$chc")
}

# Parse Switch Value
# ParseSwitchValue "$@" || return
# caller function must declare variable sw and val
ParseSwitchValue () {
    sw="$1"
    test "$#" -ge 2 && val="$2" && return
    >&2 Prompt red "ERROR: $sw requires a value."
    return 1
}

# Filter Out, case insensitive
# & $1: string variable byref
#   $2: filters
FilterOut () {
    local -n str=$1
    local fo_fs="$2"
    local IFS=','
    for fo_f in $fo_fs
    do
        test "${fo_f-}" &&
            str=$(grep -iv "^${fo_f}:" <<<"$str")
    done
}

PushdRoot () {
    git rev-parse || return
    pushd $(git rev-parse --show-toplevel)
}

Commit () {
    local summary
    local details
    local filelist
    details=$(grep -v '^#\|^\s*$' "$TMPF")
    ValidateHistory "$details" || return
    GetField summary "$details" "Solution"
    Commit_CheckLastSummary || return
    Commit_CreateRelatedFiles || return
    Commit_IsNotAmend "$@" || return 0
    git commit "$@" -m "$summary" -m "$details"
}

Commit_CheckLastSummary () {
    local last_summary
    test "$OP" = "amend" && return
    last_summary=$(git log -1 --format=%s)
    test "$last_summary" != "$summary" && return
    >&2 Prompt red "ERROR: Solution is same with last one."
    return 1
}

Commit_CreateRelatedFiles () {
    ValidateHistoryField "$details" "RelatedFiles" 2>/dev/null || return 0
    details=$(sed '/^RelatedFiles:/,$d' <<<"$details")
    ValidateJgn || return
    if test "$OP" = "amend"
    then
        git reset --soft @^ || return
        filelist=$("$JGN")
        git reset --soft ORIG_HEAD
    else
        filelist=$("$JGN")
    fi
    printf -v details "%s\n%s" "$details" "$filelist"
}

Commit_IsNotAmend () {
    local chid
    test "$OP" != "amend" && return
    chid=$(git log -1 --format=%b | grep '^Change-Id:')
    test "${chid-}" || >&2 Prompt y "Warning: Failed to get Change-ID."
    git commit "$@" -m "$summary" -m "$details" -m "$chid"
    return 1
}

#  $1:  argument
# &$2:  variable
InitParseArg () {
    local -n var=$2
    var="$1"
}

# Init template with default values set
# local dff: default template file
# local dfc: content of $dff
InitTemplate () {
    local dff
    local dfc
    dff="$(dirname "$0")/$TEMPF"
    FindFile "$dff" || return
    dfc=$(<"$dff")
    test "${df_tag-}" && SetField dfc "Tag#" "$df_tag"
    test "${df_lbl-}" && SetField dfc "Label#" "$df_lbl"
    test "${df_iss-}" && SetField dfc "Issue#" "$df_iss"
    test "${df_scp-}" && SetField dfc "Scope" "$df_scp"
    test "${df_svr-}" && SetField dfc "Severity" "$df_svr"
    test "${df_ctg-}" && SetField dfc "Category" "$df_ctg"
    test "${df_spt-}" && SetField dfc "Symptom" "$df_spt"
    test "${df_rtc-}" && SetField dfc "RootCause" "$df_rtc"
    test "${df_slt-}" && SetField dfc "Solution" "$df_slt"
    test "${df_dpd-}" && SetField dfc "SolutionDependency" "$df_dpd"
    test "${df_rlf-}" && SetField dfc "RelatedFiles" "$df_rlf"
    printf "%s\n" "$dfc" >"$TEMPF"
}

GenerateTmp () {
    test -e "$TMPF" && return
    cp "./$TEMPF" "./$TMPF"
    Prompt green "Generated file $TMPF"
    Prompt yellow \
        "Write change history in this file and save, and commit again."
    return 1
}

ShowLogo () {
cat <<LOGO

    inspurcommit v$REVISION
    Last updated: $LAST_UPDATE
    $AUTHOR

LOGO
}

ShowUsage () {
cat <<SHOWUSG
Usage:
    inspurcommit [<operation>]

Operations:
    amend, clean, diff, export, init, merge, push, template

For help on a specific operation:
    inspurcommit <operation> --help

If no operation is specified, it is used to perform a git commit. Here are
the steps:
    1. Use command 'git add <file>', or 'git add .', etc. to stage changes.
    2. Write change history in file $TMPF.
       If this file does not exist, use command 'inspurcommit' to generate
       one, and then write change history in it.
    3. Use command 'inspurcommit' to commit. Arguments, if any, will be
       passed to git commit.
SHOWUSG
}

pushUsage () {
cat <<\PUSHUSG
Usage:
    inspurcommit push [<branch>]

Push local commits to Gerrit. Default <branch> is the current. This command
is equivalent to:

    git push origin HEAD:refs/for/<branch>
PUSHUSG
}

amendUsage () {
cat <<AMENDUSG
Usage:
    inspurcommit amend [<options>]

Amend last commit with current $TMPF and staged changes. <Options> will be
passed to git commit.
AMENDUSG
}

cleanUsage () {
cat <<CLEANUSG
Usage:
    inspurcommit clean

Clean changes of overridden files.
CLEANUSG
}

exportUsage () {
cat <<\EXPORTUSG
Usage:
    inspurcommit export [-a|--all] [{-x|--exclude} <filter>,...]
                        [<filename>]

Export a change history without 'scope' filed, unless '--all' is specified.

If '--exclude' is specified, export a change history with all fields except
<filter>s. Multiple filters can be splitted by ',' as in '-x tag#,scope'.

'--exclude' implies '--all'.
EXPORTUSG
}

#TODO deprecated
exportallUsage () {
    exportUsage
}

templateUsage () {
cat <<\TEMPLATEUSG
Usage:
    inspurcommit template [<options>]

Normally, changes of the template cannot be committed, in case it is
changed by accident. When you intend to change the template, you can use
this operation. <Options> will be passed to git commit.
TEMPLATEUSG
}

initUsage () {
cat <<\INITUSG
Usage:
    inspurcommit init [<defaults>]

Defaults:
    -t, --tag <tag#>
    -l, --label <label#>
    -i, --issue <Issue#>
    -s, --scope <Scope>
    -v, --severity <Severity>
    -c, --category <Category>
    -y, --symptom <Symptom>
    -r, --rootcause <RootCause>
    -o, --solution <Solution>
    -d, --dependency <SolutionDependency>
    -f, --files <RelatedFiles>

Example:
    inspurcommit init -t "5.19_CedarIslandCrb_0ACMT_013"
INITUSG
}

diffUsage () {
cat <<\DIFFUSG
Usage:
    inspurcommit diff [<option>...]

Diff with Beyond Compare. <Option>, if any, will be passed to git difftool.
Try 'git difftool --help' for more information.

If you want to diff the staged changes, use 'inspurcommit diff --cached'.
DIFFUSG
}

mergeUsage () {
cat <<\MERGEUSG
Usage:
    inspurcommit merge [<file to merge> ...]

Resolve merge conflicts with Beyond Compare. If <file to merge> is not
specified, resolve all conflicted files one by one.
MERGEUSG
}

LookupUsage () {
    local -r OPERATION="$1"
    local argument
    test "$#" -le 1 && return
    argument="$2"
    if test "$argument" = "-?" ||
        test "$argument" = "-h" ||
        test "$argument" = "--help" ||
        test "$argument" = "--usage"
    then
        ${OPERATION}Usage
        return 1
    fi
    return 0
}

mainUsage () {
    ShowLogo
    ShowUsage
}

# Prompt
# $1:   color, red/yellow/green
# ...:  content lines
Prompt () {
    local -r RED="[91m"
    local -r GRN="[92m"
    local -r YLW="[93m"
    local -r RST="[0m"
    local -r COLOR_ARG="$1"
    local color
    shift
    case "$COLOR_ARG" in
    r|red) color="$RED" ;;
    g|grn|green) color="$GRN" ;;
    y|ylw|yellow) color="$YLW" ;;
    *)
        >&2 Prompt red "ERROR: Unknown color argument - $COLOR_ARG"
        return 1
        ;;
    esac
    printf "${color}%s${RST}\n" "$@"
}

commitOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage || return
    Commit "$@"
}

pushOp () {
    local p_br
    local sws
    while test $# -ge 1
    do
        case "$1" in
        -*)
            sws="${sws-} $1"
            shift
            ;;
        *)
            if test ! "${p_br-}"
            then
                p_br=$1
                shift
            else
                >&2 Prompt red "ERROR: Invalid argument: $1"
                return 1
            fi
        esac
    done
    git rev-parse || return
    p_br="${p_br-HEAD}"
    p_br=$(git rev-parse --abbrev-ref "$p_br") || return
    git push ${sws-} origin HEAD:refs/for/"$p_br"
}

diffOp () {
    local bcomp
    git rev-parse || return
    diffOp_GetBeyondCompare || return
    git -c "diff.tool=BeyondCompare" \
        -c "difftool.BeyondCompare.cmd=\"${bcomp}\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\"" \
        difftool --dir-diff "$@"
}

mergeOp () {
    local bcomp
    git rev-parse || return
    diffOp_GetBeyondCompare || return
    git -c "merge.tool=BeyondCompare" \
        -c "mergetool.BeyondCompare.cmd=\"${bcomp}\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\"" \
        -c "mergetool.BeyondCompare.trustExitCode=true" \
        mergetool "$@"
}

diffOp_GetBeyondCompare () {
    local -r bc_reg_p='HKCU\Software\Scooter Software\Beyond Compare'
    local -r bc_reg_k="ExePath"
    bcomp=$(reg query "$bc_reg_p" //v "$bc_reg_k" 2>/dev/null)
    if test ! "${bcomp-}"
    then
        >&2 Prompt red "ERROR: Couldn't find Beyond Compare."
        return 1
    fi
    bcomp=$(grep "ExePath" <<<"$bcomp" | sed 's/\s\{4\}.*\s\{4\}//')
}

amendOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage amend || return
    Commit --amend "$@"
}

cleanOp () {
    local st
    local fl
    local md
    local nw
    PushdRoot || return
    fl=$(grep -rni --include=*.cif '"\s*;\s*"' ./ |
        sed -e 's/^.*\s*;\s*"//' \
            -e 's/#.*$//' \
            -e 's/\s*"\s*$//' \
            -e 's/\\/\//g' |
        sort -u)
    st=$(git status --porcelain)
    md=$(grep '^ M ' <<<"$st" | sed 's/^ M //')
    nw=$(grep '^?? ' <<<"$st" | sed 's/^?? //')
    for file in $fl
    do
        if grep -qi "$file" <<<"$md"
        then
            printf "%s\n" "Checking out file $file"
            git checkout -- "$file"
        elif grep -qi "$file" <<<"$nw"
        then
            printf "%s\n" "Removing file $file"
            git clean -qf -- "$file"
        fi
    done
}

# Operation: Export a Change History
# $0 export [-a|--all] [{-x|--exclude} <field>] [<filename>]
# <filename>: Use "ChangeHistory[-All]-%h" if not specified.
# $fci: hash of the parent of INSPURCOMMIT-INIT
# $fcic: hash of INSPURCOMMIT-INIT
exportOp () {
    local fltrs
    local chfn
    local fcic
    local ch_c
    local empty
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    exportOp_Parse "$@" || return
    exportOp_GetFcic || return
    exportOp_GetContent || return
    exportOp_SetFileName
    exportOp_Write
}

exportOp_Parse () {
    local sw
    local val
    while test "$#" -gt 0
    do
        sw="$1"
        case "$sw" in
        -a|--all) test "${fltrs+set}" || fltrs="" ; shift ;;
        -x|--exclude)
            ParseSwitchValue "$@" || return
            test "${fltrs+set}" || fltrs=""
            test "$fltrs" && fltrs="$fltrs,"
            fltrs="$fltrs$val"
            set +x
            shift 2
            ;;
        *) chfn="$sw"; shift ;;
        esac
    done
    test "${fltrs+set}" || fltrs="Scope"
}

exportOp_GetFcic () {
    local fci
    FindFile "$FCIF" || return
    fci=$(<"$FCIF")
    fcic=$(git rev-list --reverse "$fci".. | head -1)
}

# b_wo_chid: commit body without change-ID
exportOp_GetContent () {
    local b_wo_chid
    b_wo_chid=$(git log --format=%b --no-merges "$fcic".. |
        sed '/^Change-Id:\s\w\{41\}$/,+1d')
    FilterOut b_wo_chid "$fltrs"
    ch_c="$b_wo_chid"
    if test "${ch_c-}"
    then
        empty=no
    else
        empty=empty
    fi
}

exportOp_SetFileName () {
    local curr_h
    test "${chfn-}" && return
    curr_h=$(git log -1 --format=%h)
    chfn="ChangeHistory-${curr_h}.txt"
}

exportOp_Write () {
    CheckFileAlreadyExists "$chfn" || return
    test "$empty" != "empty" && printf "%s\n" "$ch_c" >"$chfn"
    if ! exportOp_Write_Cat && test "$empty" = "empty"
    then
        >&2 Prompt red "ERROR: Nothing to export."
        return 1
    fi
    Prompt green "Exported file $chfn"
}

exportOp_Write_Cat () {
    local oldc
    test -e "$OLDF" || return
    d2u "$OLDF" 2>/dev/null || >&2 Prompt yellow "Warning: D2U failed."
    oldc=$(<"$OLDF")
    FilterOut oldc "$fltrs"
    if test "$empty" = "empty"
    then
        printf "%s\n" "$oldc" >"$chfn"
    else
        printf "\n%s\n" "$oldc" >>"$chfn"
    fi
}

exportallOp () {
    #TODO deprecate
    exportOp --all "$@"
}

templateOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage template || return
    Commit "$@"
}

initOp () {
    local df_tag
    local df_lbl
    local df_iss
    local df_scp
    local df_svr
    local df_ctg
    local df_spt
    local df_rtc
    local df_slt
    local df_dpd
    local df_rlf
    git rev-parse || return
    PushdRoot || return
    initOp_CheckInit || return
    initOp_CheckGitIgnore || return
    initOp_CheckStage || return
    initOp_Parse "$@" || return
    initOp_RenameTmp && initOp_Start && return
    initOp_CleanUp
    return 1
}

initOp_CheckInit () {
    CheckInit 2>/dev/null || return 0
    >&2 Prompt red "ERROR: This repository has already been initialized."
    return 1
}

initOp_CheckGitIgnore () {
    git status --porcelain | grep -q '\<.gitignore\>' || return 0
    >&2 Prompt red \
"ERROR: Please commit or stash your local changes of file '.gitignore'" \
"before init."
    return 1
}

initOp_CheckStage () {
    CheckStage 2>/dev/null || return 0
    >&2 Prompt red \
        "ERROR: Please commit or stash your staged changes before init."
    >&2 git status
    return 1
}

initOp_Parse () {
    local sw
    local val
    while test "$#" -gt 0
    do
        ParseSwitchValue "$@" || return
        initOp_Parse_Start || return
        shift 2
    done
}

initOp_Parse_Start () {
    case "$sw" in
    -t|--tag)
        InitParseArg "$val" df_tag ;;
    -l|--label)
        InitParseArg "$val" df_lbl ;;
    -i|--issue)
        InitParseArg "$val" df_iss ;;
    -s|--scope)
        InitParseArg "$val" df_scp ;;
    -v|--severity)
        InitParseArg "$val" df_svr ;;
    -c|--category)
        InitParseArg "$val" df_ctg ;;
    -y|--symptom)
        InitParseArg "$val" df_spt ;;
    -r|--rootcause)
        InitParseArg "$val" df_rtc ;;
    -o|--solution)
        InitParseArg "$val" df_slt ;;
    -d|--dependency|--solution-depen_dency)
        InitParseArg "$val" df_dpd ;;
    -f|--files|--related-files)
        InitParseArg "$val" df_rlf ;;
    *)
        >&2 Prompt red "ERROR: invalid argument - $sw"
        >&2 initUsage
        return 1
        ;;
    esac
}

initOp_CleanUp () {
    initOp_CleanUp_IsCommited && git reset @^ 1>/dev/null
    test -e "$OLDF" &&
        git clean -qfX -- "$TMPF" 1>/dev/null &&
        test ! -e "$TMPF" &&
        mv "$OLDF" "$TMPF"
    git restore --staged .
    test -e "$TEMPF" && rm "$TEMPF"
    test -e "$FCIF" && rm "$FCIF"
    git clean -qf -- .gitignore
    test -e .gitignore && git checkout -- .gitignore
}

initOp_CleanUp_IsCommited () {
    local fci
    local revlist
    local cid
    local pre_cid
    test -e "$FCIF" || return
    fci=$(<"$FCIF")
    revlist=$(git rev-list @)
    cid=$(head -1 <<<"$revlist")
    test "$fci" != "$cid" || return
    pre_cid=$(head -2 <<<"$revlist" | tail -1)
    test "$fci" = "$pre_cid" && return
    >&2 Prompt yellow \
        "Warning: Failed to get current state when cleaning up."
    return 1
}

initOp_RenameTmp () {
    test ! -e "$TMPF" && return
    CheckFileAlreadyExists "$OLDF" || return
    d2u "$TMPF" 2>/dev/null || return
    mv "$TMPF" "$OLDF" || return
    git -c "core.safecrlf=false" add "$TMPF" "$OLDF" || return
}

initOp_Start () {
    local init_title="INSPURCOMMIT-INIT"
    local init_msg
    git log --format="%H" -1 1>"$FCIF" || return
    InitTemplate || return
    printf "%s\n" "/$TMPF" "/ChangeHistory-*.txt">>.gitignore || return
    git -c "core.safecrlf=false" add "$TEMPF" "$FCIF" .gitignore || return
    printf -v init_msg "%s\n" \
"This commit was automatically generated to initialize this repository in"\
"order to use Inspur Commit Kit." || return
    git commit -m "$init_title" -m "$init_msg" 1>/dev/null || return
    Prompt green "Initialization completed successfully."
}

main () {
    local -r REVISION="0.9.3"
    local -r LAST_UPDATE="2021-11-11"
    local -r AUTHOR="Johnny Appleseed <liuzhaohui@inspur.com>"
    local -r JGN="jgnumberforthehistory"
    local -r TEMPF="$template_file_name"
    local -r TMPF="$change_history_name"
    local -r OLDF="$old_change_history_name"
    local -r FCIF="$fci_file_name"
    local -r OP="${1-}"
    LookupUsage "main" "$@" || return 0
    if test "$OP" = "-v" || test "$OP" = "--ver" || test "$OP" = "--version"
    then
        ShowLogo
        return
    fi
    if test ! "$OP" || grep -q "^-" <<<"$OP"
    then
        commitOp "$@"
        return
    fi
    shift
    case "$OP" in
    amend|clean|diff|export|init|merge|push|template) ;;
    exportall)
        #TODO deprecate
        Prompt yellow \
            "Warning: exportall is deprecated. Use 'export --all'."
        ;;
    *)
        >&2 Prompt red "ERROR: Invalid option - $OP"
        >&2 ShowUsage
        return 1
    esac
    LookupUsage "$OP" "$@" || return 0
    ${OP}Op "$@"
}

main "$@"
