#!/bin/bash

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r fci_file_name="farewell-commit-id"

ShowUsage(){
    echo "Usage:
    inspurcommit [<operation>]$LF
Operations:
    amend, export, exportall, init, push, template, usage$LF
For help on a specific operation:
    inspurcommit <operation> --help$LF
If no operation is specified, it is used to perform a git commit. Here are
the steps:
    1. Use command 'git add <file>', or 'git add .', etc. to stage changes.
    2. Write change history in file $tmpf.
       If this file does not exist, use command 'inspurcommit' to generate
       one, and then write change history in it.
    3. Use command 'inspurcommit' to commit. Arguments, if any, will be
       passed to git commit."
}

CheckInit() {
    if [ ! -e "$fcif" ] || [ ! -e "$tempf" ]
    then
        >&2 echo "${cRed}ERROR: It seems that you haven't initialize this repository.${LF}To initialize, use command 'inspurcommit init' and then 'inspurcommit push'.$cSuf"
        return 1
    fi
    return 0
}

ValidateJgn(){
    which $jgn 1>/dev/null 2>&1 && return
    echo "${cRed}ERROR: Coundn't find $jgn.$cSuf" >&2
    return 1
}

ValidateHistoryField(){
    local value=$(cat "$tmpf" | grep "^$1:" | sed "s/^$1:\s*//")
    [ "$value" ] && return
    >&2 echo "${cRed}ERROR: Field '$1' of change history is empty.$cSuf"
    return 1
}

ValidateHistory(){
    ValidateHistoryField 'Tag#' || exit
    ValidateHistoryField 'Label#' || exit
    ValidateHistoryField 'Issue#' || exit
    ValidateHistoryField 'Scope' || exit
    ValidateHistoryField 'Severity' || exit
    ValidateHistoryField 'Category' || exit
    ValidateHistoryField 'Symptom' || exit
    ValidateHistoryField 'RootCause' || exit
    ValidateHistoryField 'Solution' || exit
    ValidateHistoryField 'SolutionDependency' || exit
}

CheckStage(){
    case "$(git -c "core.safecrlf=false" diff --cached --name-only)" in
        "")
            [ "$1" == "amend" ] && return 0
            >&2 echo "${cRed}ERROR: There is no staged changes.
Stage changes to be committed with 'git add'.$cSuf"
            return 1
            ;;
        *"$tempf"*)
            [ "$1" == "template" ] && return 0
            git restore --staged "$tempf" > /dev/null
            >&2 echo "${cYlw}Warning: $tempf was staged. But was skipped.${LF}If you intend to modify the template, use command 'inspurcommit template'.$cSuf"
            CheckStage
            ;;
    esac
}

CheckFileAlreadyExists(){
    local filename="$1"
    [ -e "$filename" ] || return 0
    >&2 echo "${cRed}ERROR: File $filename already exists.$cSuf"
    return 1
}

FindFile(){
    local filename="$1"
    [ -e "$filename" ] && return 0
    >&2 echo "${cRed}ERROR: Couldn't find file $filename.$cSuf"
    return 1
}

Commit(){
    local tmpc
    local jgnc
    local summary
    local details
    local lastslt
    local chid
    tmpc=$(cat "$tmpf" | grep -v '^#\|^\s*$')
    ValidateHistory
    summary=$(echo "$tmpc" | grep '^Solution:' | sed 's/^Solution:\s*//')
    if [ ! "$op" == "amend" ]; then
        lastslt=$(git log -1 --format=%s)
        if [ "$lastslt" == "$summary" ]; then
            >&2 echo "${cRed}ERROR: Solution is same with last one.$cSuf"
            return 1
        fi
    fi
    if ValidateHistoryField "RelatedFiles" 2>/dev/null
    then
        tmpc=$(echo "$tmpc" | sed '/^RelatedFiles:/,$d')
        ValidateJgn || exit
        if [ "$op" == "amend" ]
        then
            git reset --soft @^ || exit
            jgnc=$($jgn)
            git reset --soft ORIG_HEAD
        else
            jgnc=$($jgn)
        fi
        tmpc="$tmpc$LF$jgnc"
    fi
    details="$tmpc"
    if [ "$op" == "amend" ]; then
        chid=$(git log -1 --format=%b | grep '^Change-Id:')
        [ "$chid" ] || \
            >&2 echo "${cYlw}Warning: Failed to get Change-ID.$cSuf"
        git commit "$@" -m "$summary" -m "$details" -m "$chid"
    else
        git commit "$@" -m "$summary" -m "$details"
    fi
}

# Export a Change History
# $1: exclude-field: 'none', 'Scope'.
# $2: [ filename ]: Use "ChangeHistory[-All]-%h" if not specified.
Export(){
    local currhash
    local chfn
    local fci
    local fcic
    local mode
    local ch_content
    CheckInit || return
    fci=$(cat "$fcif")
    fcic=$(git rev-list --reverse "$fci"..@ | head -1)
    if [ "$1" == "none" ] || [ ! "$1" ]; then
        mode="all"
        ch_content=$(git log "$fcic".. --format="%b" | sed '/^Change-Id:\s\w\{41\}$/,+1d')
    else
        mode="notall"
        ch_content=$(git log "$fcic".. --format="%b" | grep -v "^$1:" | sed '/^Change-Id:\s\w\{41\}$/,+1d')
    fi
    if [ ! "$ch_content" ]; then
        >&2 echo "${cRed}ERROR: Nothing to export.$cSuf"
        return 1
    fi
    currhash=$(git log -1 --format='%h')
    case "$mode" in
        "all")
            chfn=${2:-"ChangeHistory-All-${currhash}.txt"}
            ;;
        "notall")
            chfn=${2:-"ChangeHistory-${currhash}.txt"}
            ;;
        *)
            >&2 echo "ERROR: Export mode is neither all nor notall."
            exit 1
            ;;
    esac
    CheckFileAlreadyExists "$chfn" || return
    echo "$ch_content" > "$chfn"
    echo "${cGrn}Exported file $chfn$cSuf"
    return
}

#  $1:  switch
#  $2:  argument
# &$3:  variable
InitParseArg(){
    if [ ! "$2" ]
    then
        >&2 echo "${cRed}ERROR: '$1' requires a value.$cSuf"
        exit 1
    fi
    local -n var=$3
    var="$2"
}

InitTemplate(){
    local dff=$(dirname "$0")/"$tempf"
    local dfc
    FindFile "$dff" || return 1
    dfc=$(cat "$dff")
    [ "$dfTag" ] && dfc=$(echo "$dfc" | \
        sed "s/^Tag#:.*$/Tag#: $dfTag/")
    [ "$dfLbl" ] && dfc=$(echo "$dfc" | \
        sed "s/^Label#:.*$/Label#: $dfLbl/")
    [ "$dfIss" ] && dfc=$(echo "$dfc" | \
        sed "s/^Issue#:.*$/Issue#: $dfIss/")
    [ "$dfScp" ] && dfc=$(echo "$dfc" | \
        sed "s/^Scope:.*$/Scope: $dfScp/")
    [ "$dfSvr" ] && dfc=$(echo "$dfc" | \
        sed "s/^Severity:.*$/Severity: $dfSvr/")
    [ "$dfCtg" ] && dfc=$(echo "$dfc" | \
        sed "s/^Category:.*$/Category: $dfCtg/")
    [ "$dfSpt" ] && dfc=$(echo "$dfc" | \
        sed "s/^Symptom:.*$/Symptom: $dfSpt/")
    [ "$dfRtc" ] && dfc=$(echo "$dfc" | \
        sed "s/^RootCause:.*$/RootCause: $dfRtc/")
    [ "$dfSlt" ] && dfc=$(echo "$dfc" | \
        sed "s/^Solution:.*$/Solution: $dfSlt/")
    [ "$dfDpd" ] && dfc=$(echo "$dfc" | \
        sed "s/^SolutionDependency:.*$/SolutionDependency: $dfDpd/")
    [ "$dfRlf" ] && dfc=$(echo "$dfc" | \
        sed "s/^RelatedFiles:.*$/RelatedFiles: $dfRlf/")
    echo "$dfc" > "$tempf"
}

GenerateTmp(){
    FindFile "$tmpf" 2>/dev/null && return
    cp ./"$tempf" ./"$tmpf"
    echo "${cGrn}Generated file ${cYlw}$tmpf$cSuf"
    echo "${cGrn}Write change history in this file and save, and commit again.$cSuf"
    return 1
}

pushUsage(){
    echo "Usage:
    inspurcommit push [<branch>]$LF
Push local commits to Gerrit. By default, <branch> is 'master'.
This command is equivalent to:$LF
    git push origin HEAD:refs/for/<branch>"
}

amendUsage(){
    echo "Usage:
    inspurcommit amend [<options>]$LF
Amend last commit with current $tmpf and staged changes.
<options> will be passed to git commit. "
}

exportUsage(){
    echo "Usage:
    inspurcommit export [<filename>]
    inspurcommit exportall [<filename>]$LF
Export a change history.
If 'export' is used, will filter out 'scope'."
}

templateUsage(){
    echo "Usage:
    inspurcommit template [<options>]$LF
Normally, changes of the template cannot be committed, in case it is
changed by accident. When you intend to change the template, you can use
this operation.
<options> will be passed to git commit."
}

initUsage(){
    echo "Usage:
    inspurcommit init [<defaults>]$LF
Defaults:
    -t, --tag <tag#>
    -l, --label <label#>
    -i, --issue <Issue#>
    -s, --scope <Scope>
    -v, --severity <Severity>
    -c, --category <Category>
    -y, --symptom <Symptom>
    -r, --rootcause <RootCause>
    -o, --solution <Solution>
    -d, --dependency <SolutionDependency>
    -f, --files <RelatedFiles>$LF
Example:
    inspurcommit init -t \"5.19_CedarIslandCrb_0ACMT_013\""
}

LookupUsage(){
    [ ! "$2" ] && return
    case "$2" in
        "-?"|"-h"|"--help"|"--usage")
            ${1}Usage
            return 1
            ;;
    esac
    return 0
}

declare -r rev='0.4.1'
declare -r lastupdt='2021-07-29'
declare -r author='Johnny Appleseed <liuzhaohui@inspur.com>'
declare -r jgn="jgnumberforthehistory"
declare -r tempf="$template_file_name"
declare -r tmpf="$change_history_name"
declare -r fcif="$fci_file_name"
declare -r cRed="[91m"
declare -r cGrn="[92m"
declare -r cYlw="[93m"
declare -r cSuf="[0m"
declare -r LF='
'

declare -r op="${1,,}"
case "$op" in
    "?"|"-?"|"-h"|"--help"|"--usage"|"help"|"usage")
        echo
        echo "    inspurcommit v$rev"
        echo "    Last updated: $lastupdt"
        echo "    $author"
        echo
        ShowUsage
        exit
        ;;

    ""|"-"*)
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage || exit
        Commit "$@"
        ;;

    "push")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        p_br="${1:-master}"
        shift
        git push origin HEAD:refs/for/"$p_br" "$@"
        exit
        ;;

    "amend")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage amend || exit
        Commit --amend "$@"
        ;;

    "export")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        Export "Scope" "$@"
        ;;

    "exportall")
        shift
        LookupUsage "export" "$@" || exit 0
        git rev-parse || exit
        Export "none" "$@"
        ;;

    "template")
        shift
        LookupUsage "$op" "$@" || exit 0
        git rev-parse || exit
        CheckInit || exit
        GenerateTmp || exit 0
        CheckStage template || exit
        Commit "$@"
        ;;

    "init")
        shift
        while [ $# -gt 0 ]
        do
            case "${1,,}" in
                -t|--tag)
                    InitParseArg "$1" "$2" dfTag
                    shift 2
                    ;;
                -l|--label)
                    InitParseArg "$1" "$2" dfLbl
                    shift 2
                    ;;
                -i|--issue)
                    InitParseArg "$1" "$2" dfIss
                    shift 2
                    ;;
                -s|--scope)
                    InitParseArg "$1" "$2" dfScp
                    shift 2
                    ;;
                -v|--severity)
                    InitParseArg "$1" "$2" dfSvr
                    shift 2
                    ;;
                -c|--category)
                    InitParseArg "$1" "$2" dfCtg
                    shift 2
                    ;;
                -y|--symptom)
                    InitParseArg "$1" "$2" dfSpt
                    shift 2
                    ;;
                -r|--rootcause)
                    InitParseArg "$1" "$2" dfRtc
                    shift 2
                    ;;
                -o|--solution)
                    InitParseArg "$1" "$2" dfSlt
                    shift 2
                    ;;
                -d|--dependency|--solution-dependency)
                    InitParseArg "$1" "$2" dfDpd
                    shift 2
                    ;;
                -f|--files|--related-files)
                    InitParseArg "$1" "$2" dfRlf
                    shift 2
                    ;;
                '-?'|-h|--help|--usage)
                    initUsage
                    exit
                    ;;
                *)
                    >&2 echo "${cRed}ERROR: invalid argument - $1$cSuf"
                    >&2 initUsage
                    exit 1
                    ;;
            esac
        done
        git rev-parse || exit
        if [ ! -e ./.git ]; then
            >&2 echo "${cRed}ERROR: Please init in the root directory.$cSuf"
            exit 1
        fi
        if CheckInit 2>/dev/null
        then
            >&2 echo "${cRed}ERROR: This repository has already been initialized.$cSuf"
            exit 1
        fi
        case "$(git status --porcelain)" in
            *".gitignore"*)
                >&2 echo "${cRed}Please commit or stash your local changes of file '.gitignore' before init.$cSuf"
                exit 1
                ;;
        esac
        if CheckStage 2>/dev/null
        then
            >&2 echo "${cRed}ERROR: Please commit or stash your staged changes before init.$cSuf"
            >&2 git status
            exit 1
        fi
        [ -e "$tmpf" ] && \
            mv "$tmpf" "Old$tmpf" && \
            (git -c "core.safecrlf=false" add "$tmpf" "Old$tmpf" || exit)
        git log --format="%H" -1 > "$fcif" && \
            InitTemplate && \
            echo "/$tmpf" >> .gitignore && \
            echo "/ChangeHistory-*.txt" >> .gitignore && \
            git -c "core.safecrlf=false" add "$tempf" "$fcif" .gitignore && \
            git commit -m "INSPURCOMMIT-INIT" -m "
This commit was automatically generated to initialize this repository in
order to use Inspur Commit Kit." 1>/dev/null && \
            echo "${cGrn}Initialization completed successfully.$cSuf"
        ;;
    *)
        >&2 echo "${cRed}ERROR: Invalid option - $1$cSuf"
        >&2 ShowUsage
        exit 1
        ;;
esac
