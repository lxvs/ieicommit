#!/bin/sh
set -o nounset
set -o noglob

template_file_name="ChangeHistoryTemplate"
change_history_name="ChangeHistory"
change_history_extension=".txt"
old_change_history_name="Old$change_history_name$change_history_extension"
fci_file_name="farewell-commit-id"

CheckInit () {
    local quiet=
    local tree
    while test $# -ge 1
    do
        case $1 in
        -q|--quiet)
            quiet=1
            shift
            ;;
        --no-quiet)
            quiet=
            shift
            ;;
        *)
            >&2 printf "%s\n" "warning: invalid \`$1' in CheckInit"
            ;;
        esac
    done
    if git rev-parse --verify --quiet --no-revs HEAD
    then
        tree=$(git ls-tree --full-tree --name-only HEAD) || exit
        printf "%s" "$tree" | grep --quiet "^$FCIF\$" &&
            printf "%s" "$tree" | grep --quiet "^$TEMPF$EXT\$" &&
            return
    fi
    test "$quiet" && return 1
    >&2 Prompt red \
        "error: This repository haven't been initialized." \
        "Use command \`inspurcommit init --help' for help."
    return 1
}

jgnInsNum () {
    awk '
    NR == 1 {
        print $0
        next
    }
    {
        printf "%d. %s\n", NR-1, $0
    }
    '
}

jgn () {
    local title="RelatedFiles:"
    local mod_t="Modified:"
    local add_t="Added:"
    local del_t="Deleted:"
    local ren_t="Renamed:"
    local cpy_t="Copied:"
    local oth_t="Other:"
    local mod add del ren cpy oth
    local tree=HEAD
    test "$1" = "amend" && tree=HEAD^
    git diff-index --quiet --name-only --cached $tree && return
    mod=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=M)
    add=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=A)
    del=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=D)
    ren=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=R)
    cpy=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=C)
    oth=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=madrc)
    test "$mod" && mod=$(printf "%s\n%s\n" "$mod_t" "$mod" | jgnInsNum)
    test "$add" && add=$(printf "%s\n%s\n" "$add_t" "$add" | jgnInsNum)
    test "$del" && del=$(printf "%s\n%s\n" "$del_t" "$del" | jgnInsNum)
    test "$ren" && ren=$(printf "%s\n%s\n" "$ren_t" "$ren" | jgnInsNum)
    test "$cpy" && cpy=$(printf "%s\n%s\n" "$cpy_t" "$cpy" | jgnInsNum)
    test "$oth" && oth=$(printf "%s\n%s\n" "$oth_t" "$oth" | jgnInsNum)
    printf "%s\n" ${title:+"$title"} ${mod:+"$mod"} ${add:+"$add"} ${del:+"$del"} ${ren:+"$ren"} ${cpy:+"$cpy"} ${oth:+"$oth"}
}

ValidateHistoryField () {
    local content=$1
    local field=$2
    test "$(GetField "$content" "$field")" && return
    >&2 Prompt red "error: Field \`$field' of change history is empty."
    return 1
}

ValidateHistory () {
    local content=$1
    ValidateHistoryField "$content" "Tag#" || return
    ValidateHistoryField "$content" "Label#" || return
    ValidateHistoryField "$content" "Issue#" || return
    ValidateHistoryField "$content" "Scope" || return
    ValidateHistoryField "$content" "Severity" || return
    ValidateHistoryField "$content" "Category" || return
    ValidateHistoryField "$content" "Symptom" || return
    ValidateHistoryField "$content" "RootCause" || return
    ValidateHistoryField "$content" "Solution" || return
    ValidateHistoryField "$content" "SolutionDependency" || return
}

CheckStage () {
    local amend= template=
    while test $# -ge 1
    do
        case $1 in
        amend)
            amend=1
            shift
            ;;
        template)
            template=1
            shift
            ;;
        *)
            die "error: invalid argument \`$1' for CheckStage"
            ;;
        esac
    done
    if ! git rev-parse --verify --quiet --no-revs HEAD
    then
        ! git diff-index --quiet --cached $(git hash-object -t tree /dev/null)
        return
    fi
    if git diff-index --quiet --cached HEAD
    then
        test "$amend" && return
        Prompt >&2 red "error: nothing staged" "Stage changes to be committed with \`git add'."
        return 1
    fi
    git diff-index --name-only --cached HEAD |
        grep --quiet "^$TEMPF$EXT\$" ||
        return 0
    CheckStage_HasTemp
}

CheckStage_HasTemp () {
    test "$template" && return
    git ls-tree --full-tree HEAD -- "$TEMPF$EXT" |
        git update-index --index-info ||
        return
    die "error: Template \`$TEMPF$EXT' was staged, and was unstaged by me." \
        "If you intend to modify the template, stage it again and use command" \
        "\`inspurcommit template'. Otherwise, use \`inspurcommit' again to" \
        "commit without changing \`$TEMPF$EXT'"
}

GetField () {
    local chc=$1
    local field=$2
    printf "%s" "$chc" | grep "^${field}:" | sed "s/^${field}:\s*//"
}

SetField () {
    local chc=$1
    local field=$2
    local content=$3
    if test "$content"
    then
        printf "%s" "$chc" | sed "s/^${field}:.*$/${field}: ${content}/"
    else
        printf "%s" "$chc"
    fi
}

FilterOut () {
    local str=$1
    local filters=$2
    local filter
    local IFS=','
    for filter in $filters
    do
        str=$(printf "%s" "$str" | grep -iv "^$filter:")
    done
    printf "%s" "$str"
}

CdRoot () {
    git rev-parse || exit
    cd "$(git rev-parse --show-toplevel)" || exit
}

Commit () {
    local summary
    local details
    local filelist
    details=$(grep -v '^#\|^\s*$' "$TMPF$EXT")
    ValidateHistory "$details" || return
    summary=$(GetField "$details" "Solution")
    Commit_CheckLastSummary
    Commit_CreateRelatedFiles || return
    Commit_IsNotAmend "$@" || return 0
    git commit "$@" -m "$summary" -m "$details"
}

Commit_CheckLastSummary () {
    local last_summary
    test "$op" = "amend" && return
    last_summary=$(git diff-tree --no-patch --format=%s HEAD)
    test "$last_summary" != "$summary" && return
    die "error: Solution is same with last one."
}

Commit_CreateRelatedFiles () {
    ValidateHistoryField "$details" "RelatedFiles" 2>/dev/null || return 0
    details=$(printf "%s" "$details" | sed '/^RelatedFiles:/,$d')
    filelist=$(jgn $op)
    details=$(printf "%s\n%s" "$details" "$filelist")
}

Commit_IsNotAmend () {
    local chid
    test "$op" != "amend" && return
    if git rev-parse --quiet --verify --no-revs HEAD^2
    then
        git commit --no-edit "$@" || exit
    else
        chid=$(git diff-tree --no-patch --format=%b HEAD | grep '^Change-Id:')
        test "$chid" || >&2 Prompt y "warning: Failed to get Change-ID."
        git commit -m "$summary" -m "$details" -m "$chid" "$@" || exit
    fi
    return 1
}

InitTemplate () {
    local dff dfc
    dff="$(dirname "$0")/$TEMPF$EXT"
    if ! test -e "$dff"
    then
        >&2 Prompt red "failed to find file \`$dff'"
        return 1
    fi
    dfc=$(<"$dff")
    dfc=$(SetField "$dfc" "Tag#" "$df_tag")
    dfc=$(SetField "$dfc" "Label#" "$df_lbl")
    dfc=$(SetField "$dfc" "Issue#" "$df_iss")
    dfc=$(SetField "$dfc" "Scope" "$df_scp")
    dfc=$(SetField "$dfc" "Severity" "$df_svr")
    dfc=$(SetField "$dfc" "Category" "$df_ctg")
    dfc=$(SetField "$dfc" "Symptom" "$df_spt")
    dfc=$(SetField "$dfc" "RootCause" "$df_rtc")
    dfc=$(SetField "$dfc" "Solution" "$df_slt")
    dfc=$(SetField "$dfc" "SolutionDependency" "$df_dpd")
    dfc=$(SetField "$dfc" "RelatedFiles" "$df_rlf")
    printf "%s\n" "$dfc" >"$TEMPF$EXT"
}

GenerateTmp () {
    test -e "$TMPF$EXT" && return
    git cat-file blob HEAD:"$TEMPF$EXT" >"$TMPF$EXT" || return
    Prompt yellow "Generated file \`$TMPF$EXT'" \
        "Write change history in this file and save, and commit again."
    return 1
}

ShowLogo () {
cat <<EOF

    inspurcommit $version
    $author

EOF
}

ShowUsage () {
cat <<EOF
usage: inspurcommit [<operation>]

Operation is \`commit' if not specified.

These are all operations used in various situations:

manipulate current repository
    init        Initialize current repository to use inspurcommit
    template    Commit with template changes

work on the current change
    commit      Record changes to the repository
    amend       Amend previous commit
    push        Push local commits to Gerrit for review
    clean       Clean up overridden files
    merge       Resolve merge conflicts with Beyond Compare
    purge       Regenerate a change history from template
    load        Read a specific commit message to change history

examine things
    diff        Show changes using beyond Compare
    export      Export a full change history

get detailed help for a specific operation:
    inspurcommit <operation> --help
    inspurcommit commit --help
EOF
}

commitUsage () {
cat <<EOF
usage: inspurcommit [<options>]

Commit staged changes with messages read from file \`$TMPF$EXT'.
If this file does not exist, will be generated from template. Fill it in and
use this command again to commit.

Options will be passed to git-commit; try \`git commit -h' or \`git help commit'
for more information.
EOF
}

purgeUsage () {
cat <<EOF
usage: inspurcommit purge

Remove \`$TMPF$EXT' and regenerate one from template.
EOF
}

pushUsage () {
cat <<EOF
usage: inspurcommit push [<options>] [<branch>]

Push local commits to Gerrit for review. Default <branch> is the current one.
Options will be passed to git-push. This command is equivalent to:

    git push [<options>] origin HEAD:refs/for/<branch>
EOF
}

amendUsage () {
cat <<EOF
usage: inspurcommit amend [<options>]

Amend previous commit with staged changes, messages read from \`$TMPF$EXT'.

Options will be passed to git-commit.

To amend with template changes, use \`amendtemplate' instead.
EOF
}

amendtemplateUsage () {
cat <<EOF
usage: inspurcommit amendtemplate [<options>]

Amend previous commit with staged changes, messages read from \`$TMPF$EXT'.

Options will be passed to git-commit.

This is for commits including template changes.
EOF
}

cleanUsage () {
cat <<EOF
usage: inspurcommit clean

Clean up overridden files.
EOF
}

exportUsage () {
cat <<EOF
usage: inspurcommit export [<options>] [--] [<filename>]

Export a change history without \`scope' field, unless \`--all' is specified.

    -a, --all               Export all fields
    -x, --exclude FIELD     Exclude specific fileds; separate multiple fields
                            with \`,' as in \`-xFILED1,FILED2'. Implies \`--all'
EOF
}

templateUsage () {
cat <<EOF
usage: inspurcommit template [<options>]

Normally, changes of the template cannot be committed, in case it is changed
by accident. When you intend to change the template, you can use this
operation. Options will be passed to git-commit.
EOF
}

initUsage () {
cat <<EOF
usage: inspurcommit init [<options>]

Initialize current repository in order to use inspurcommit.

    -t, --tag           Specify content of tag# in template
    -l, --label         Specify content of label in template
    -i, --issue         Specify content of issue# in template
    -s, --scope         Specify content of scope in template
    -v, --severity      Specify content of severity in template
    -c, --category      Specify content of category in template
    -y, --symptom       Specify content of symptom in template
    -r, --rootcause     Specify content of rootcause in template
    -o, --solution      Specify content of solution in template
    -d, --dependency    Specify content of solution dependency in template
    -f, --files         Specify content of related files in template
EOF
}

loadUsage () {
cat <<EOF
usage: inspurcommit load [<commit-id>]

Read messages of specific <commit-id> to \`$TMPF$EXT'.
<commit-id> is the current HEAD if not specified.
EOF
}

diffUsage () {
cat <<EOF
usage: inspurcommit diff [<options>]

Show changes using Beyond Compare. Options will be passed to git-difftool.
Try \`git difftool -h' or \`git help difftool' for more information.

Path to Beyond Compare will be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
EOF
}

mergeUsage () {
cat <<EOF
usage: inspurcommit merge [<file to merge> ...]

Resolve merge conflicts using Beyond Compare. If <file to merge> is not
specified, resolve all conflicted files one by one.

By default, git creates \`*.orig' backup files while resolving merges. These
are safe to remove once a file has been merged and its git mergetool
session has completed.

Setting the mergetool.keepBackup configuration variable to false causes git
mergetool to automatically remove the backup as files are successfully
merged.

Path to Beyond Compare will be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
EOF
}

LookupUsage () {
    local argument
    test "$#" -le 1 && return
    argument=$2
    if test "$argument" = "-?" ||
        test "$argument" = "-h" ||
        test "$argument" = "--help" ||
        test "$argument" = "--usage"
    then
        ${1}Usage
        return 1
    fi
    return 0
}

mainUsage () {
    ShowLogo
    ShowUsage
}

die () {
    while test $# -ge 1
    do
        Prompt >&2 red "$1"
        shift
    done
    exit 1
}

Prompt () {
    local red="[91m"
    local green="[92m"
    local yellow="[93m"
    local reset="[0m"
    local color=$1
    shift
    if ! test -t 1
    then
        printf "%s\n" "$@"
        return
    fi
    case $color in
    r|red)
        color=$red
        ;;
    g|grn|green)
        color=$green
        ;;
    y|ylw|yellow)
        color=$yellow
        ;;
    *)
        printf >&2 "warning: invalid color \`%s'\n" "$color"
        printf "%s\n" "$@"
        return
        ;;
    esac
    printf "${color}%s${reset}\n" "$@"
}

commitOp () {
    CheckInit || return
    CdRoot
    GenerateTmp || return 0
    CheckStage || return
    Commit "$@"
}

pushOp () {
    local br_d
    local p_br= sws=
    while test $# -ge 1
    do
        case "$p_br,$1" in
        *,-*)
            sws="$sws $1"
            shift
            ;;
        '',*)
            p_br=$1
            shift
            ;;
        *)
            die "error: invalid argument: $1"
            ;;
        esac
    done
    br_d=$(git rev-parse --abbrev-ref HEAD) || exit
    git push $sws origin HEAD:refs/for/"${p_br:-$br_d}"
}

diffOp () {
    local bc=
    git rev-parse || exit
    diffOp_GetBeyondCompare
    git difftool --extcmd="$bc" --dir-diff "$@"
}

mergeOp () {
    local bc=
    git rev-parse || exit
    diffOp_GetBeyondCompare
    git -c "merge.tool=BeyondCompare" \
        -c "mergetool.BeyondCompare.cmd=\"$bc\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\"" \
        -c "mergetool.BeyondCompare.trustExitCode=true" \
        mergetool "$@"
}

diffOp_GetBeyondCompare () {
    test "$JG_BC_PATH" && bc=$JG_BC_PATH && return
    printf "%s" "$OS" | grep -qi '^win' || die "error: this operation is for Windows only for now."
    bc="$(cygpath -u "$PROGRAMFILES")/Beyond Compare 4/BComp.exe" && test -x "$bc" && return
    bc="$(cygpath -u "$PROGRAMFILES") (x86)/Beyond Compare 4/BComp.exe" && test -x "$bc" && return
    bc="$(cygpath -u "$PROGRAMFILES")/Beyond Compare 3/bcomp.exe" && test -x "$bc" && return
    bc="$(cygpath -u "$PROGRAMFILES") (x86)/Beyond Compare 3/BComp.exe" && test -x "$bc" && return
    die "error: Couldn't find Beyond Compare." "Please defined the path to BComp.exe in JG_BC_PATH and restart shell."
}

amendOp () {
    CheckInit || return
    CdRoot
    GenerateTmp || return 0
    CheckStage amend || return
    Commit --amend "$@"
}

amendtemplateOp () {
    CheckInit || return
    CdRoot
    GenerateTmp || return 0
    CheckStage amend template || return
    Commit --amend "$@"
}

cleanOp () {
    local fl tor toc tmpm tmpo
    CdRoot
    fl=$(grep -rho --include=*.cif ';\s*"[^"]\+[^" ]' . | sed -e 's/^;\s*"//' -e 's/\\/\//g' | sort -u)
    tmpm=$(mktemp) || return
    tmpo=$(mktemp) || return
    git ls-files --modified | sort >"$tmpm"
    git ls-files --others | sort >"$tmpo"
    tor=$(printf "%s" "$fl" | comm -12 - "$tmpm")
    rm "$tmpm"
    toc=$(printf "%s" "$fl" | comm -12 - "$tmpo")
    rm "$tmpo"
    test "$tor" && printf "%s" "$tor" | xargs -d '\n' git checkout-index --force --
    test "$toc" && printf "%s" "$toc" | xargs -d '\n' rm -f --
    return 0
}

exportOp () {
    local fltrs ch_c
    local chfn=
    CheckInit || return
    CdRoot
    exportOp_Parse "$@" || return
    exportOp_GetContent || return
    exportOp_SetFileName
    exportOp_Write
}

exportOp_Parse_Again () {
    local mode=$1 eff eqeff eqval flag
    shift
    sn=1
    case $mode in
    no)
        eff="${1#--no-}"
        ;;
    2)
        eff="${1#--}"
        ;;
    1)
        eff="${1#-}"
        ;;
    *)
        die "error: unknown mode: $mode"
        ;;
    esac
    case "$eff,$mode" in
    all,no)
        die "error: invalid switch \`--no-all'"
        ;;
    all,2)
        test "${fltrs+set}" || fltrs=
        ;;
    exclude,no)
        fltrs=
        ;;
    exclude,2)
        test $# -ge 2 || die "error: switch \`$eff' requires a value"
        fltrs="${fltrs-},$2"
        sn=2
        ;;
    exclude=*,2)
        eqeff="${eff%%=*}"
        eqval="${eff#"$eqeff="}"
        test "$eqval" || die "error: switch \`$eqeff' requires a value"
        fltrs="${fltrs-},$eqval"
        ;;
    *,1)
        while test ${#eff} -ge 1
        do
            flag="$(printf "%s" "$eff" | cut -c 1)"
            eff="${eff#?}"
            case $flag in
            a)
                fltrs=
                ;;
            x)
                if test "$eff"
                then
                    fltrs="${fltrs-},$eff"
                    eff=
                elif test $# -ge 2
                then
                    fltrs="${fltrs-},$2"
                    sn=2
                else
                    die "error: switch \`$flag' requires a value"
                fi
                ;;
            *)
                die "error: invalid switch: $flag"
                ;;
            esac
        done
        ;;
    *)
        die "error: invalid switch: $eff"
        ;;
    esac
}

exportOp_Parse () {
    local -i sn=1
    while test "$#" -gt 0
    do
        case $1 in
        --)
            shift
            break
            ;;
        --no-*)
            exportOp_Parse_Again "no" "$@"
            shift $sn
            ;;
        --*)
            exportOp_Parse_Again "2" "$@"
            shift $sn
            ;;
        -*)
            exportOp_Parse_Again "1" "$@"
            shift $sn
            ;;
        *)
            test "$chfn" && die "error: invalid argument: $1"
            chfn=$1
            shift
            ;;
        esac
    done
    case "$chfn,$#" in
    *,0)
        ;;
    ,1)
        chfn=$1
        ;;
    *)
        die "error: too many arguments"
        ;;
    esac
    test "${fltrs+set}" || fltrs="Scope"
}

exportOp_GetContent () {
    local fci fci_range
    fci=$(git cat-file blob HEAD:"$FCIF" 2>/dev/null) || return
    if test "$fci" = "0"
    then
        fci_range="^$(git rev-list HEAD | tail -n1)"
    else
        fci_range="^$(git rev-list HEAD ^$fci | tail -n1)"
    fi
    ch_c=$(FilterOut "$(git --no-pager log --no-color --format=%b --no-merges HEAD $fci_range | sed '/^Change-Id:\s\w\{41\}$/,+1d')" "$fltrs")
}

exportOp_SetFileName () {
    local curr_h
    test "$chfn" && return
    curr_h=$(git rev-parse --verify --short HEAD) || exit
    chfn="$TMPF-$curr_h$EXT"
}

exportOp_Write () {
    cat /dev/null >"$chfn"
    test "$ch_c" && printf "%s\n" "$ch_c" >>"$chfn"
    if ! exportOp_Write_Cat && test ! "$ch_c"
    then
        rm -f "$chfn"
        die "error: nothing to export"
    fi
    Prompt green "Exported file $chfn"
}

exportOp_Write_Cat () {
    local oldc
    oldc=$(git cat-file blob HEAD:"$OLDF" 2>/dev/null) || return
    oldc=$(FilterOut "$oldc" "$fltrs")
    test "$ch_c" && printf "\n" >>"$chfn"
    printf "%s\n" "$oldc" >>"$chfn"
}

templateOp () {
    CheckInit || return
    CdRoot
    GenerateTmp || return 0
    CheckStage template || return
    Commit "$@"
}

initOp () {
    local df_tag= df_lbl= df_iss= df_scp= df_svr= df_ctg= df_spt=
    local df_rtc= df_slt= df_dpd= df_rlf=
    CdRoot
    CheckInit --quiet && die "error: repository already initialized"
    initOp_CheckStage || return
    initOp_Parse "$@" || return
    initOp_RenameTmp && initOp_Start && return
    initOp_CleanUp
    return 1
}

initOp_CheckStage () {
    CheckStage 2>/dev/null || return 0
    >&2 Prompt red \
        "error: Please commit or stash your staged changes before init."
    >&2 git status
    return 1
}

initOp_Parse () {
    local -i sn
    while test "$#" -gt 0
    do
        case $1 in
        --no-*)
            initOp_Parse_Again no "$@"
            shift $sn
            ;;
        --*)
            initOp_Parse_Again 2 "$@"
            shift $sn
            ;;
        -*)
            initOp_Parse_Again 1 "$@"
            shift $sn
            ;;
        *)
            ;;
        esac
    done
}

initOp_Parse_Again () {
    local mode=$1 eff
    shift
    sn=2
    case $mode in
    no)
        sn=1
        eff="${1#--no-}"
        initOp_ParseNo "$@"
        ;;
    2)
        eff="${1#--}"
        initOp_Parse2 "$@"
        ;;
    1)
        eff="${1#-}"
        initOp_Parse1 "$@"
        ;;
    *)
        die "error: unknown mode: $mode"
        ;;
    esac
}

initOp_ParseNo () {
    case $eff in
    tag)
        df_tag=
        ;;
    label)
        df_lbl=
        ;;
    issue)
        df_iss=
        ;;
    scope)
        df_scp=
        ;;
    severity)
        df_svr=
        ;;
    category)
        df_ctg=
        ;;
    symptom)
        df_spt=
        ;;
    rootcause)
        df_rtc=
        ;;
    solution)
        df_slt=
        ;;
    dependency|solution-dependency)
        df_dpd=
        ;;
    files|related-files)
        df_rlf=
        ;;
    *)
        die "error: invalid switch: no-$eff"
        ;;
    esac
}

initOp_Parse2 () {
    local val=
    test $# -ge 2 && val=$2
    case $eff in
    tag)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_tag=$val
        ;;
    tag=*)
        sn=1
        val=${eff#tag=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_tag=$val
        ;;
    label)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_lbl=$val
        ;;
    label=*)
        sn=1
        val=${eff#label=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_lbl=$val
        ;;
    issue)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_iss=$val
        ;;
    issue=*)
        sn=1
        val=${eff#issue=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_iss=$val
        ;;
    scope)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_scp=$val
        ;;
    scope=*)
        sn=1
        val=${eff#scope=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_scp=$val
        ;;
    severity)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_svr=$val
        ;;
    severity=*)
        sn=1
        val=${eff#severity=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_svr=$val
        ;;
    category)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_ctg=$val
        ;;
    category=*)
        sn=1
        val=${eff#category=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_ctg=$val
        ;;
    symptom)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_spt=$val
        ;;
    symptom=*)
        sn=1
        val=${eff#symptom=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_spt=$val
        ;;
    rootcause)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_rtc=$val
        ;;
    rootcause=*)
        sn=1
        val=${eff#rootcause=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_rtc=$val
        ;;
    solution)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_spt=$val
        ;;
    solution=*)
        sn=1
        val=${eff#solution=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_spt=$val
        ;;
    dependency|solution-dependency)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    dependency=*)
        sn=1
        val=${eff#dependency=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    solution-dependency=*)
        sn=1
        val=${eff#solution-dependency=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    files|related-files)
        test "$val" || die "error: switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    files=*)
        sn=1
        val=${eff#files=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    related-files=*)
        sn=1
        val=${eff#related-files=}
        eff=${eff%"=$val"}
        test "$val" || die "error: switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    *)
        die "error: invalid switch: $eff"
        ;;
    esac
}

initOp_Parse1 () {
    local sw val
    if test ${#eff} -gt 1
    then
        sn=1
        sw="$(printf "%s" "$eff" | cut -c 1)"
        val=${eff#?}
    elif test $# -ge 2
    then
        sw=$eff
        val=$2
    else
        die "error: switch \`$sw' requires a value"
    fi
    case $sw in
    t)
        df_tag=$val
        ;;
    l)
        df_lbl=$val
        ;;
    i)
        df_iss=$val
        ;;
    s)
        df_scp=$val
        ;;
    v)
        df_svr=$val
        ;;
    c)
        df_ctg=$val
        ;;
    y)
        df_spt=$val
        ;;
    r)
        df_rtc=$val
        ;;
    o)
        df_slt=$val
        ;;
    d)
        df_dpd=$val
        ;;
    f)
        df_rlf=$val
        ;;
    *)
        die "error: invalid switch: $sw"
        ;;
    esac
}

initOp_CleanUp () {
    local reason="cleaning up after failed to initialize inspurcommit"
    if ! git rev-parse --verify --quiet --no-revs HEAD
    then
        rm -- "$FCIF" "$TEMPF$EXT"
        return
    fi
    test "$(git ls-tree HEAD -- "$FCIF")" &&
        git update-ref -m "$reason" HEAD HEAD^ &&
        git restore --staged --worktree -- \
        "$OLDF" "$TMPF$EXT" "$FCIF" .gitignore
}

initOp_RenameTmp () {
    local old obj
    local dirty=
    old=$(git cat-file blob HEAD:"$TMPF$EXT" 2>/dev/null) || return 0
    test "$(git ls-files -- "$OLDF")" && die "error: file \`$OLDF' found in index"
    obj=$(printf "%s\n" "$old" | git hash-object -t blob -w --stdin) ||
        return
    printf "%s %s %s\t%s" 100644 blob $obj "$OLDF" |
        git update-index --add --index-info ||
        return
    git checkout-index -- "$OLDF" || return
    git diff-files -q -- "$TMPF$EXT" || dirty=1
    if test "$dirty"
    then
        Prompt >&2 y "warning: File \`$TMPF$EXT' was kept as is in worktree."
    else
        git update-index --force-remove -- "$TMPF$EXT"
    fi
}

initOp_Start () {
    local init_title="INSPURCOMMIT-INIT"
    local init_msg oldgi newgi
    local dirty=
    if git rev-parse --verify --quiet --no-revs HEAD
    then
        git rev-parse --verify HEAD >"$FCIF" || return
    else
        printf "0" >"$FCIF" || return
    fi
    git diff-files --quiet -- .gitignore || dirty=1
    InitTemplate || return
    if oldgi=$(git cat-file blob HEAD:.gitignore 2>/dev/null)
    then
        newgi=$(printf "%s\n" "$oldgi" "/$TMPF$EXT" "/$TMPF-*$EXT")
        gimode=$(git ls-tree --full-tree --format="%(objectmode)" HEAD -- .gitignore)
    else
        newgi=$(printf "%s\n" "/$TMPF$EXT" "/$TMPF-*$EXT")
        gimode="100644"
    fi
    printf "%s %s %s\t%s" $gimode blob $(printf "%s\n" "$newgi" | git hash-object --stdin -t blob -w) .gitignore |
        git update-index --add --index-info ||
        return
    git update-index --add -- "$TEMPF$EXT" "$FCIF" || return
    if test "$dirty"
    then
        >&2 Prompt y "warning: File .gitignore was kept as is in worktree."
    else
        git checkout-index --force -- .gitignore
    fi
    init_msg=$(printf "%s\n" \
        "This commit was automatically generated to initialize this repository" \
        "in order to use Inspur Commit Kit.") || return
    git commit -m "$init_title" -m "$init_msg" 1>/dev/null || return
    Prompt green "Initialization completed successfully."
}

purgeOp () {
    test $# -eq 0 || die "error: too many arguments"
    CdRoot
    test ! -e "$TMPF$EXT" || rm "$TMPF$EXT" || return
    GenerateTmp 1>/dev/null || return 0
}

loadOp () {
    local id msg
    test $# -le 1 || die "error: too many arguments"
    CheckInit || return
    id=$(git rev-parse --verify "${1-HEAD}") || return
    git rev-parse --verify --quiet --no-revs $id^2 &&
        die "error: refuse to load a merge"
    CdRoot
    msg=$(git diff-tree --no-patch --format=%b $id | sed '/^RelatedFiles:/,$d')
    test "$msg" || die "error: got an empty result"
    printf "%s\n" "$msg" "$(grep '^RelatedFiles:' "$TEMPF$EXT")" >"$TMPF$EXT"
}

main () {
    local version="0.15.0"
    local author="Liu, Zhao-hui <liuzhaohui@inspur.com>"
    local TEMPF=$template_file_name
    local TMPF=$change_history_name
    local OLDF=$old_change_history_name
    local EXT=$change_history_extension
    local FCIF=$fci_file_name
    local JG_BC_PATH=${JG_BC_PATH-}
    local OS=${OS-}
    local op=${1-}
    LookupUsage "main" "$@" || exit 0
    case $op in
    amend|amendtemplate|clean|commit|diff|export|init|load|merge|purge|push|template)
        shift
        ;;
    --version)
        ShowLogo
        exit
        ;;
    ''|-*)
        op=commit
        ;;
    *)
        die "error: invalid argument: $op" "Try \`inspurcommit --help' for help."
        ;;
    esac
    LookupUsage $op "$@" || return 0
    ${op}Op "$@"
}

main "$@"
