#!/bin/bash
set -o nounset
set -o noglob

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r old_change_history_name="Old$change_history_name"
declare -r fci_file_name="farewell-commit-id"

pushd () {
    command pushd "$@" 1>/dev/null
}

popd () {
    command popd "$@" 1>/dev/null
}

CheckInit () {
    local quiet=
    local tree
    while test $# -ge 1
    do
        case $1 in
        -q|--quiet)
            quiet=1
            shift
            ;;
        --no-quiet)
            quiet=
            shift
            ;;
        *)
            >&2 printf "%s\n" "warning: invalid \`$1' in CheckInit"
            ;;
        esac
    done
    tree=$(git ls-tree --full-tree --name-only HEAD) || exit
    grep -G --quiet "^$FCIF$" <<<"$tree" &&
        grep -G --quiet "^$TEMPF$" <<<"$tree" &&
        return
    test "$quiet" && return 1
    >&2 Prompt red \
        "error: This repository haven't been initialized." \
        "Use command \`inspurcommit init --help' for help."
    return 1
}

jgnInsNum () {
    vim - --not-a-term -es \
        "+let b:currline=search('^$1\$')" \
        "+/^$1\$/+,\$s/^/\\=line('.')-b:currline.'. '/ge" \
        "+%p|q!"
}

jgn () {
    local -r title="RelatedFiles:"
    local -r mod_t="Modified:"
    local -r add_t="Added:"
    local -r del_t="Deleted:"
    local -r ren_t="Renamed:"
    local -r cpy_t="Copied:"
    local -r oth_t="Other:"
    local mod add del ren cpy oth
    local tree=HEAD
    test "$1" = "amend" && tree=HEAD^
    git diff-index --quiet --name-only --cached $tree && return
    mod=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=M)
    add=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=A)
    del=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=D)
    ren=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=R)
    cpy=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=C)
    oth=$(git diff-index --name-only --cached $tree -M100% -C100% --diff-filter=madrc)
    test "$mod" &&
        mod=$(printf "\n%s\n%s\n" "$mod_t" "$mod" | jgnInsNum "$mod_t")
    test "$add" &&
        add=$(printf "\n%s\n%s\n" "$add_t" "$add" | jgnInsNum "$add_t")
    test "$del" &&
        del=$(printf "\n%s\n%s\n" "$del_t" "$del" | jgnInsNum "$del_t")
    test "$ren" &&
        ren=$(printf "\n%s\n%s\n" "$ren_t" "$ren" | jgnInsNum "$ren_t")
    test "$cpy" &&
        cpy=$(printf "\n%s\n%s\n" "$cpy_t" "$cpy" | jgnInsNum "$cpy_t")
    test "$oth" &&
        oth=$(printf "\n%s\n%s\n" "$oth_t" "$oth" | jgnInsNum "$oth_t")
    printf "%s" "$title" "$mod" "$add" "$del" "$ren" "$cpy" "$oth"
}

ValidateHistoryField () {
    local content=$1
    local field=$2
    test "$(GetField "$content" "$field")" && return
    >&2 Prompt red "error: Field \`$field' of change history is empty."
    return 1
}

ValidateHistory () {
    local content=$1
    ValidateHistoryField "$content" "Tag#" || return
    ValidateHistoryField "$content" "Label#" || return
    ValidateHistoryField "$content" "Issue#" || return
    ValidateHistoryField "$content" "Scope" || return
    ValidateHistoryField "$content" "Severity" || return
    ValidateHistoryField "$content" "Category" || return
    ValidateHistoryField "$content" "Symptom" || return
    ValidateHistoryField "$content" "RootCause" || return
    ValidateHistoryField "$content" "Solution" || return
    ValidateHistoryField "$content" "SolutionDependency" || return
}

CheckStage () {
    local option=${1-normal}
    local stage
    if git diff-index --quiet --cached HEAD
    then
        CheckStage_NoStage
        return
    fi
    git diff-index --name-only --cached HEAD |
        grep -G --quiet "^$TEMPF\$" ||
        return 0
    CheckStage_HasTemp
}

CheckStage_NoStage () {
    test "$option" = "amend" && return
    >&2 Prompt red \
        "error: There is no staged changes." \
        "Stage changes to be committed with \`git add'."
    return 1
}

CheckStage_HasTemp () {
    test "$option" = "template" && return
    git ls-tree --full-tree HEAD -- .gitignore |
        git update-index --index-info ||
        return
    err \
"Template \`$TEMPF' was staged, and was unstaged by me." \
"If you intend to modify the template, stage it again and use command" \
"\`inspurcommit template'. Otherwise, use \`inspurcommit' again to" \
"commit without changing \`$TEMPF'"
}

GetField () {
    local -r chc=$1
    local -r field=$2
    grep "^${field}:" <<<"$chc" | sed "s/^${field}:\s*//"
}

SetField () {
    local -r chc=$1
    local -r field=$2
    local -r content=$3
    if test "$content"
    then
        sed "s/^${field}:.*$/${field}: ${content}/" <<<"$chc"
    else
        printf "%s" "$chc"
    fi
}

FilterOut () {
    local str=$1
    local filters=$2
    local filter
    local -r IFS=","
    for filter in $filters
    do
        str=$(grep -iv "^$filter:" <<<"$str")
    done
    printf "%s" "$str"
}

PushdRoot () {
    git rev-parse || exit
    pushd "$(git rev-parse --show-toplevel)"
}

Commit () {
    local summary
    local details
    local filelist
    details=$(grep -v '^#\|^\s*$' "$TMPF")
    ValidateHistory "$details" || return
    summary=$(GetField "$details" "Solution")
    Commit_CheckLastSummary || return
    Commit_CreateRelatedFiles || return
    Commit_IsNotAmend "$@" || return 0
    git commit "$@" -m "$summary" -m "$details"
}

Commit_CheckLastSummary () {
    local last_summary
    test "$op" = "amend" && return
    last_summary=$(git diff-tree --no-patch --format=%s HEAD)
    test "$last_summary" != "$summary" && return
    >&2 Prompt red "error: Solution is same with last one."
    return 1
}

Commit_CreateRelatedFiles () {
    ValidateHistoryField "$details" "RelatedFiles" 2>/dev/null || return 0
    details=$(sed '/^RelatedFiles:/,$d' <<<"$details")
    filelist=$(jgn $op)
    printf -v details "%s\n%s" "$details" "$filelist"
}

Commit_IsNotAmend () {
    local chid
    test "$op" != "amend" && return
    chid=$(git diff-tree --no-patch --format=%b HEAD | grep '^Change-Id:')
    test "$chid" || >&2 Prompt y "warning: Failed to get Change-ID."
    git commit "$@" -m "$summary" -m "$details" -m "$chid"
    return 1
}

InitTemplate () {
    local dff dfc
    dff="$(dirname "$0")/$TEMPF"
    test -e "$dff" || err "failed to find file \`$dff'"
    dfc=$(<"$dff")
    dfc=$(SetField "$dfc" "Tag#" "$df_tag")
    dfc=$(SetField "$dfc" "Label#" "$df_lbl")
    dfc=$(SetField "$dfc" "Issue#" "$df_iss")
    dfc=$(SetField "$dfc" "Scope" "$df_scp")
    dfc=$(SetField "$dfc" "Severity" "$df_svr")
    dfc=$(SetField "$dfc" "Category" "$df_ctg")
    dfc=$(SetField "$dfc" "Symptom" "$df_spt")
    dfc=$(SetField "$dfc" "RootCause" "$df_rtc")
    dfc=$(SetField "$dfc" "Solution" "$df_slt")
    dfc=$(SetField "$dfc" "SolutionDependency" "$df_dpd")
    dfc=$(SetField "$dfc" "RelatedFiles" "$df_rlf")
    printf "%s\n" "$dfc" >"$TEMPF"
}

GenerateTmp () {
    test -e "$TMPF" && return
    git cat-file blob HEAD:"$TEMPF" >"$TMPF" || return
    Prompt yellow "Generated file \`$TMPF'" \
        "Write change history in this file and save, and commit again."
    return 1
}

ShowLogo () {
cat <<EOF

    inspurcommit $version
    $author

EOF
}

ShowUsage () {
cat <<EOF
usage: inspurcommit [<operation>]

Operation is \`commit' if not specified.

These are all operations used in various situations:

manipulate current repository
    init        Initialize current repository to use inspurcommit
    template    Commit with template changes
    clean       Clean up overridden files

work on the current change
    commit      Record changes to the repository
    amend       Amend previous commit
    push        Push local commits to Gerrit for review
    merge       Resolve merge conflicts with Beyond Compare
    purge       Regenerate a change history from template
    load        Read a specific commit message to change history

examine things
    diff        Show changes using beyond Compare
    export      Export a full change history

get detailed help for a specific operation:
    inspurcommit <operation> --help
    inspurcommit commit --help
EOF
}

commitUsage () {
cat <<EOF
usage: inspurcommit [<options>]

Commit staged changes with messages read from file \`$TMPF'. If this file does
not exist, will be generated from template. Fill it in and use this command
again to commit.

Options will be passed to git-commit; try \`git commit -h' or \`git help commit'
for more information.
EOF
}

purgeUsage () {
cat <<EOF
usage: inspurcommit purge

Remove \`$TMPF' and regenerate one from template.
EOF
}

pushUsage () {
cat <<\EOF
usage: inspurcommit push [<options>] [<branch>]

Push local commits to Gerrit for review. Default <branch> is the current one.
Options will be passed to git-push. This command is equivalent to:

    git push [<options>] origin HEAD:refs/for/<branch>
EOF
}

amendUsage () {
cat <<EOF
usage: inspurcommit amend [<options>]

Amend previous commit with staged changes, messages read from \`$TMPF'
Options will be passed to git-commit.
EOF
}

cleanUsage () {
cat <<EOF
usage: inspurcommit clean

Clean up overridden files.
EOF
}

exportUsage () {
cat <<EOF
usage: inspurcommit export [<options>] [--] [<filename>]

Export a change history without \`scope' field, unless \`--all' is specified.

    -a, --all               Export all fields
    -x, --exclude FIELD     Exclude specific fileds; separate multiple fields
                            with \`,' as in \`-xFILED1,FILED2'. Implies \`--all'
EOF
}

templateUsage () {
cat <<\EOF
usage: inspurcommit template [<options>]

Normally, changes of the template cannot be committed, in case it is changed
by accident. When you intend to change the template, you can use this
operation. Options will be passed to git-commit.
EOF
}

initUsage () {
cat <<\EOF
usage: inspurcommit init [<options>]

Initialize current repository in order to use inspurcommit.

    -t, --tag           Specify content of tag# in template
    -l, --label         Specify content of label in template
    -i, --issue         Specify content of issue# in template
    -s, --scope         Specify content of scope in template
    -v, --severity      Specify content of severity in template
    -c, --category      Specify content of category in template
    -y, --symptom       Specify content of symptom in template
    -r, --rootcause     Specify content of rootcause in template
    -o, --solution      Specify content of solution in template
    -d, --dependency    Specify content of solution dependency in template
    -f, --files         Specify content of related files in template
EOF
}

loadUsage () {
cat <<EOF
usage: inspurcommit load [<commit-id>]

Read messages of specific <commit-id> to \`$TMPF'.
<commit-id> is the current HEAD if not specified.
EOF
}

diffUsage () {
cat <<EOF
usage: inspurcommit diff [<options>]

Show changes using Beyond Compare. Options will be passed to git-difftool.
Try \`git difftool -h' or \`git help difftool' for more information.

Path to Beyond Compare will be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
EOF
}

mergeUsage () {
cat <<EOF
usage: inspurcommit merge [<file to merge> ...]

Resolve merge conflicts using Beyond Compare. If <file to merge> is not
specified, resolve all conflicted files one by one.

By default, git creates \`*.orig' backup files while resolving merges. These
are safe to remove once a file has been merged and its git mergetool
session has completed.

Setting the mergetool.keepBackup configuration variable to false causes git
mergetool to automatically remove the backup as files are successfully
merged.

Path to Beyond Compare will be queried from Registry; it can be overridden
by setting environment variable JG_BC_PATH to the absolute path to Beyound
Compare.
EOF
}

LookupUsage () {
    local -r OPERATION=$1
    local argument
    test "$#" -le 1 && return
    argument=$2
    if test "$argument" = "-?" ||
        test "$argument" = "-h" ||
        test "$argument" = "--help" ||
        test "$argument" = "--usage"
    then
        ${OPERATION}Usage
        return 1
    fi
    return 0
}

mainUsage () {
    ShowLogo
    ShowUsage
}

err () {
    local -r red="[91m"
    local -r rst="[0m"
    local msg="${1-unspecific error}"
    >&2 printf "${red}error: %s${rst}\n" "$msg"
    while test $# -ge 2
    do
        >&2 printf "${red}%s${rst}\n" "$2"
        shift
    done
    exit 1
}

# Prompt
# $1:   color, red/yellow/green
# ...:  content lines
Prompt () {
    local -r RED="[91m"
    local -r GRN="[92m"
    local -r YLW="[93m"
    local -r RST="[0m"
    local -r COLOR_ARG=$1
    local color
    shift
    case $COLOR_ARG in
    r|red)
        color=$RED
        ;;
    g|grn|green)
        color=$GRN
        ;;
    y|ylw|yellow)
        color=$YLW
        ;;
    *)
        >&2 Prompt red "error: unknown color argument: $COLOR_ARG"
        return 1
        ;;
    esac
    printf -- "${color}%s${RST}\n" "$@"
}

commitOp () {
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage || return
    Commit "$@"
}

pushOp () {
    local br_d
    local p_br= sws=
    while test $# -ge 1
    do
        case "$p_br,$1" in
        *,-*)
            sws="$sws $1"
            shift
            ;;
        '',*)
            p_br=$1
            shift
            ;;
        *)
            err "invalid argument: $1"
            ;;
        esac
    done
    br_d=$(git rev-parse --abbrev-ref HEAD) || exit
    git push $sws origin HEAD:refs/for/"${p_br:-$br_d}"
}

diffOp () {
    local bc=
    git rev-parse || exit
    diffOp_GetBeyondCompare || return
    git difftool --extcmd="$bc" --dir-diff "$@"
}

mergeOp () {
    local bc=
    git rev-parse || exit
    diffOp_GetBeyondCompare || return
    git -c "merge.tool=BeyondCompare" \
        -c "mergetool.BeyondCompare.cmd=\"$bc\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\"" \
        -c "mergetool.BeyondCompare.trustExitCode=true" \
        mergetool "$@"
}

diffOp_GetBeyondCompare () {
    local -r bc_reg_p='HKCU\Software\Scooter Software\Beyond Compare'
    local -r bc_reg_k="ExePath"
    test "$JG_BC_PATH" && bc=$JG_BC_PATH && return
    grep -Gqi '^win' <<<"$OS" ||
        err "this operation is for Windows only for now."
    bc=$(reg query "$bc_reg_p" //v "$bc_reg_k" 2>/dev/null)
    if test ! "$bc"
    then
        >&2 Prompt red "error: Couldn't find Beyond Compare." \
            "Please defined the path to bcompare.exe in JG_BC_PATH and restart shell."
        return 1
    fi
    bc=$(grep "ExePath" <<<"$bc" | sed 's/\s\{4\}.*\s\{4\}//')
}

amendOp () {
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage amend || return
    Commit --amend "$@"
}

cleanOp () {
    local fl tor toc
    PushdRoot || return
    fl=$(grep -Grho --include=*.cif ';\s*"[^"]\+[^" ]' . |
        sed -e 's/^;\s*"//' \
            -e 's/\\/\//g' |
        sort -u)
    tor=$(comm -12 - <<<"$fl" <(git ls-files --modified | sort))
    toc=$(comm -12 - <<<"$fl" <(git ls-files --others | sort))
    test "$tor" && xargs <<<"$tor" -d '\n' git checkout-index --
    test "$toc" && xargs <<<"$toc" -d '\n' rm -f --
    return 0
}

# Operation: Export a Change History
# $0 export [-a|--all] [{-x|--exclude} <field>] [[--] <filename>]
# <filename>: Use "ChangeHistory[-All]-%h" if not specified.
# $fci: hash of the parent of INSPURCOMMIT-INIT
# $fcic: hash of INSPURCOMMIT-INIT
exportOp () {
    local fltrs fcic ch_c
    local chfn=
    CheckInit || return
    PushdRoot || return
    exportOp_Parse "$@" || return
    exportOp_GetContent || return
    exportOp_SetFileName
    exportOp_Write
}

exportOp_Parse_Again () {
    local mode=$1 eff eqeff eqval flag
    shift
    sn=1
    case $mode in
    no)
        eff="${1#--no-}"
        ;;
    2)
        eff="${1#--}"
        ;;
    1)
        eff="${1#-}"
        ;;
    *)
        err "unknown mode: $mode"
        ;;
    esac
    case "$eff,$mode" in
    all,no)
        err "invalid switch \`--no-all'"
        ;;
    all,2)
        test "${fltrs+set}" || fltrs=
        ;;
    exclude,no)
        fltrs=
        ;;
    exclude,2)
        test $# -ge 2 || err "switch \`$eff' requires a value"
        fltrs="${fltrs-},$2"
        sn=2
        ;;
    exclude=*,2)
        eqeff="${eff%%=*}"
        eqval="${eff#$eqeff=}"
        test "$eqval" || err "switch \`$eqeff' requires a value"
        fltrs="${fltrs-},$eqval"
        ;;
    *,1)
        while test ${#eff} -ge 1
        do
            flag="${eff:0:1}"
            eff="${eff#?}"
            case $flag in
            a)
                fltrs=
                ;;
            x)
                if test "$eff"
                then
                    fltrs="${fltrs-},$eff"
                    eff=
                elif test $# -ge 2
                then
                    fltrs="${fltrs-},$2"
                    sn=2
                else
                    err "switch \`$flag' requires a value"
                fi
                ;;
            *)
                err "invalid switch: $flag"
                ;;
            esac
        done
        ;;
    *)
        err "invalid switch: $eff"
        ;;
    esac
}

exportOp_Parse () {
    local -i sn=1
    while test "$#" -gt 0
    do
        case $1 in
        --)
            shift
            break
            ;;
        --no-*)
            exportOp_Parse_Again "no" "$@"
            shift $sn
            ;;
        --*)
            exportOp_Parse_Again "2" "$@"
            shift $sn
            ;;
        -*)
            exportOp_Parse_Again "1" "$@"
            shift $sn
            ;;
        *)
            test "$chfn" && err "invalid argument: $1"
            chfn=$1
            shift
            ;;
        esac
    done
    case "$chfn,$#" in
    *,0)
        ;;
    ,1)
        chfn=$1
        ;;
    *)
        err "too many arguments"
        ;;
    esac
    test "${fltrs+set}" || fltrs="Scope"
}

exportOp_GetContent () {
    local fci
    fci=$(git cat-file blob HEAD:"$FCIF" 2>/dev/null) || return
    fcic=$(git rev-list HEAD ^$fci | tail -n1)
    ch_c=$(FilterOut "$(git rev-list --no-commit-header --format=%b --no-merges HEAD ^$fcic | sed '/^Change-Id:\s\w\{41\}$/,+1d')" "$fltrs")
}

exportOp_SetFileName () {
    local curr_h
    test "$chfn" && return
    curr_h=$(git rev-parse --verify --short HEAD) || exit
    chfn="ChangeHistory-${curr_h}.txt"
}

exportOp_Write () {
    cat /dev/null >"$chfn"
    test "$ch_c" && printf "%s\n" "$ch_c" >>"$chfn"
    if ! exportOp_Write_Cat && test ! "$ch_c"
    then
        rm -f "$chfn"
        err "nothing to export"
    fi
    Prompt green "Exported file $chfn"
}

exportOp_Write_Cat () {
    local oldc
    oldc=$(git cat-file blob HEAD:"$OLDF" 2>/dev/null) || return
    oldc=$(FilterOut "$oldc" "$fltrs")
    test "$ch_c" && printf "\n" >>"$chfn"
    printf "%s\n" "$oldc" >>"$chfn"
}

templateOp () {
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage template || return
    Commit "$@"
}

initOp () {
    local df_tag= df_lbl= df_iss= df_scp= df_svr= df_ctg= df_spt=
    local df_rtc= df_slt= df_dpd= df_rlf=
    PushdRoot || return
    initOp_CheckInit || return
    initOp_CheckStage || return
    initOp_Parse "$@" || return
    initOp_RenameTmp && initOp_Start && return
    initOp_CleanUp
    return 1
}

initOp_CheckInit () {
    CheckInit --quiet || return 0
    >&2 Prompt red "error: This repository has already been initialized."
    return 1
}

initOp_CheckStage () {
    CheckStage 2>/dev/null || return 0
    >&2 Prompt red \
        "error: Please commit or stash your staged changes before init."
    >&2 git status
    return 1
}

initOp_Parse () {
    local -i sn
    while test "$#" -gt 0
    do
        case $1 in
        --no-*)
            initOp_Parse_Again no "$@"
            shift $sn
            ;;
        --*)
            initOp_Parse_Again 2 "$@"
            shift $sn
            ;;
        -*)
            initOp_Parse_Again 1 "$@"
            shift $sn
            ;;
        *)
            ;;
        esac
    done
}

initOp_Parse_Again () {
    local mode=$1 eff
    shift
    sn=2
    case $mode in
    no)
        sn=1
        eff="${1#--no-}"
        initOp_ParseNo "$@"
        ;;
    2)
        eff="${1#--}"
        initOp_Parse2 "$@"
        ;;
    1)
        eff="${1#-}"
        initOp_Parse1 "$@"
        ;;
    *)
        err "unknown mode: $mode"
        ;;
    esac
}

initOp_ParseNo () {
    case $eff in
    tag)
        df_tag=
        ;;
    label)
        df_lbl=
        ;;
    issue)
        df_iss=
        ;;
    scope)
        df_scp=
        ;;
    severity)
        df_svr=
        ;;
    category)
        df_ctg=
        ;;
    symptom)
        df_spt=
        ;;
    rootcause)
        df_rtc=
        ;;
    solution)
        df_slt=
        ;;
    dependency|solution-dependency)
        df_dpd=
        ;;
    files|related-files)
        df_rlf=
        ;;
    *)
        err "invalid switch: no-$eff"
        ;;
    esac
}

initOp_Parse2 () {
    local val=
    test $# -ge 2 && val=$2
    case $eff in
    tag)
        test "$val" || err "switch \`$eff' requires a value"
        df_tag=$val
        ;;
    tag=*)
        sn=1
        val=${eff#tag=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_tag=$val
        ;;
    label)
        test "$val" || err "switch \`$eff' requires a value"
        df_lbl=$val
        ;;
    label=*)
        sn=1
        val=${eff#label=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_lbl=$val
        ;;
    issue)
        test "$val" || err "switch \`$eff' requires a value"
        df_iss=$val
        ;;
    issue=*)
        sn=1
        val=${eff#issue=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_iss=$val
        ;;
    scope)
        test "$val" || err "switch \`$eff' requires a value"
        df_scp=$val
        ;;
    scope=*)
        sn=1
        val=${eff#scope=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_scp=$val
        ;;
    severity)
        test "$val" || err "switch \`$eff' requires a value"
        df_svr=$val
        ;;
    severity=*)
        sn=1
        val=${eff#severity=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_svr=$val
        ;;
    category)
        test "$val" || err "switch \`$eff' requires a value"
        df_ctg=$val
        ;;
    category=*)
        sn=1
        val=${eff#category=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_ctg=$val
        ;;
    symptom)
        test "$val" || err "switch \`$eff' requires a value"
        df_spt=$val
        ;;
    symptom=*)
        sn=1
        val=${eff#symptom=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_spt=$val
        ;;
    rootcause)
        test "$val" || err "switch \`$eff' requires a value"
        df_rtc=$val
        ;;
    rootcause=*)
        sn=1
        val=${eff#rootcause=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_rtc=$val
        ;;
    solution)
        test "$val" || err "switch \`$eff' requires a value"
        df_spt=$val
        ;;
    solution=*)
        sn=1
        val=${eff#solution=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_spt=$val
        ;;
    dependency|solution-dependency)
        test "$val" || err "switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    dependency=*)
        sn=1
        val=${eff#dependency=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    solution-dependency=*)
        sn=1
        val=${eff#solution-dependency=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_dpd=$val
        ;;
    files|related-files)
        test "$val" || err "switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    files=*)
        sn=1
        val=${eff#files=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    related-files=*)
        sn=1
        val=${eff#related-files=}
        eff=${eff%=$val}
        test "$val" || err "switch \`$eff' requires a value"
        df_rlf=$val
        ;;
    *)
        err "invalid switch: $eff"
        ;;
    esac
}

initOp_Parse1 () {
    local sw val
    if test ${#eff} -gt 1
    then
        sn=1
        sw=${eff:0:1}
        val=${eff#?}
    elif test $# -ge 2
    then
        sw=$eff
        val=$2
    else
        err "switch \`$sw' requires a value"
    fi
    case $sw in
    t)
        df_tag=$val
        ;;
    l)
        df_lbl=$val
        ;;
    i)
        df_iss=$val
        ;;
    s)
        df_scp=$val
        ;;
    v)
        df_svr=$val
        ;;
    c)
        df_ctg=$val
        ;;
    y)
        df_spt=$val
        ;;
    r)
        df_rtc=$val
        ;;
    o)
        df_slt=$val
        ;;
    d)
        df_dpd=$val
        ;;
    f)
        df_rlf=$val
        ;;
    *)
        err "invalid switch: $sw"
        ;;
    esac
}

initOp_CleanUp () {
    local -r reason="cleaning up after failed to initialize inspurcommit"
    test "$(git ls-tree HEAD -- "$FCIF")" &&
        git update-ref -m "$reason" HEAD HEAD^ &&
        git restore --staged --worktree -- \
        "$OLDF" "$TMPF" "$FCIF" .gitignore
}

initOp_RenameTmp () {
    local old obj
    local dirty=
    old=$(git cat-file blob HEAD:"$TMPF") || return 0
    test "$(git ls-files -- "$OLDF")" && err "file \`$OLDF' found in index"
    obj=$(printf "%s\n" "$old" | git hash-object -t blob -w --stdin) ||
        return
    printf "%s %s %s\t%s" 100644 blob $obj "$OLDF" |
        git update-index --add --index-info ||
        return
    git checkout-index -- "$OLDF" || return
    git diff-files -q -- "$TMPF" || dirty=1
    if test "$dirty"
    then
        Prompt >&2 y "warning: File \`$TMPF' was kept as is in worktree."
    else
        git update-index --force-remove -- "$TMPF"
    fi
}

initOp_Start () {
    local init_title="INSPURCOMMIT-INIT"
    local init_msg newgi
    local dirty=
    git rev-parse --verify HEAD >"$FCIF" || return
    git diff-files --quiet -- .gitignore || dirty=1
    InitTemplate || return
    printf -v newgi "%s\n" "$(git cat-file blob HEAD:.gitignore)" \
        "/$TMPF" "/ChangeHistory-*.txt"
    git ls-tree --full-tree HEAD -- .gitignore |
        sed "s/[[:xdigit:]]\{40\}/$(printf "%s" "$newgi" | git hash-object --stdin -t blob -w)/" |
        git update-index --index-info ||
        return
    git update-index --add -- "$TEMPF" "$FCIF" || return
    if test "$dirty"
    then
        >&2 Prompt y "warning: File .gitignore was kept as is in worktree."
    else
        git checkout-index --force -- .gitignore
    fi
    printf -v init_msg "%s\n" \
"This commit was automatically generated to initialize this repository" \
"in order to use Inspur Commit Kit." || return
    git commit -m "$init_title" -m "$init_msg" 1>/dev/null || return
    Prompt green "Initialization completed successfully."
}

purgeOp () {
    test $# -eq 0 || err "too many arguments"
    PushdRoot || return
    test ! -e "$TMPF" || rm "$TMPF" || return
    GenerateTmp 1>/dev/null || return 0
}

loadOp () {
    local id msg
    test $# -le 1 || err "too many arguments"
    CheckInit || return
    id=$(git rev-parse --verify "${1-HEAD}") || return
    git rev-parse --verify --quiet --no-revs $id^2 &&
        err "refuse to load a merge"
    PushdRoot || return
    msg=$(git diff-tree --no-patch --format=%b $id | sed '/^RelatedFiles:/,$d')
    test "$msg" || err "got an empty result"
    printf "%s\n" "$msg" "$(grep '^RelatedFiles:' "$TEMPF")" >"$TMPF"
}

main () {
    local -r version="0.13.0"
    local -r author="Johnny Appleseed <liuzhaohui@inspur.com>"
    local -r TEMPF=$template_file_name
    local -r TMPF=$change_history_name
    local -r OLDF=$old_change_history_name
    local -r FCIF=$fci_file_name
    local -r JG_BC_PATH=${JG_BC_PATH-}
    local -r OS=${OS-}
    local op=${1-}
    LookupUsage "main" "$@" || exit 0
    case $op in
    amend|clean|commit|diff|export|init|load|merge|purge|push|template)
        shift
        ;;
    --version)
        ShowLogo
        exit
        ;;
    ''|-*)
        op=commit
        ;;
    *)
        >&2 Prompt red "error: invalid argument: $op" \
            "Try \`inspurcommit --help' for help."
        exit 1
        ;;
    esac
    LookupUsage $op "$@" || return 0
    ${op}Op "$@"
}

main "$@"
