#!/bin/bash
set -o nounset   # abort on unbound variable

declare -r template_file_name="ChangeHistoryTemplate.txt"
declare -r change_history_name="ChangeHistory.txt"
declare -r old_change_history_name="Old$change_history_name"
declare -r fci_file_name="farewell-commit-id"

pushd () {
    command pushd "$@" 1>/dev/null
}

popd () {
    command popd "$@" 1>/dev/null
}

CheckInit () {
    PushdRoot
    test -e "$FCIF" && test -e "$TEMPF" && popd && return
    >&2 Prompt red \
        "error: This repository haven't been initialized." \
        "Use command 'inspurcommit init --help' for help."
    popd
    return 1
}

jgnInsNum () {
    vim - --not-a-term -es "+%s/$1//ge" \
        "+let b:currline=search('^$2\$')" \
        "+/^$2\$/+,\$s/^/\\=line('.')-b:currline.'. '/ge" \
        "+%p|q!"
}

jgn () {
    local -r title='RelatedFiles:'
    local -r mod_title='Modified:'
    local -r add_title='Added:'
    local -r del_title='Deleted:'
    local -r ren_title='Renamed:'
    local -r cpy_title='Copied:'
    local -r modtag='^M. '
    local -r addtag='^A. '
    local -r deltag='^D. '
    local -r rentag='^R. '
    local -r cpytag='^C. '
    local staged=$(git status --porcelain | grep '^[MADRC]')
    if test ! "$(git diff --cached --name-only 2>/dev/null)"
    then
        Prompt red "error: no staged change"
        return 1
    fi
    moded=$(printf -- "%s" "$staged" | grep "$modtag")
    test "${moded-}" &&
        moded=$(printf -- "\n%s\n%s\n" "$mod_title" "$moded" |
        jgnInsNum "$modtag" "$mod_title")
    added=$(printf -- "%s\n" "$staged" | grep "$addtag")
    test "${added-}" &&
        added=$(printf -- "\n%s\n%s\n" "$add_title" "$added" |
        jgnInsNum "$addtag" "$add_title")
    deled=$(printf -- "%s\n" "$staged" | grep "$deltag")
    test "${deled-}" &&
        deled=$(printf -- "\n%s\n%s\n" "$del_title" "$deled" |
        jgnInsNum "$deltag" "$del_title")
    rened=$(printf -- "%s\n" "$staged" | grep "$rentag")
    test "${rened-}" &&
        rened=$(printf -- "\n%s\n%s\n" "$ren_title" "$rened" |
        jgnInsNum "$rentag" "$ren_title")
    cpyed=$(printf -- "%s\n" "$staged" | grep "$cpytag")
    test "${cpyed-}" &&
        cpyed=$(printf -- "\n%s\n%s\n" "$cpy_title" "$cpyed" |
        jgnInsNum "$cpytag" "$cpy_title")
    printf -- "%s" "$title" "$moded" "$added" "$deled" "$rened" "$cpyed"
}

ValidateHistoryField () {
    local value
    local content="$1"
    local field="$2"
    GetField value "$content" "$field"
    test "${value-}" && return
    >&2 Prompt red "error: Field '$field' of change history is empty."
    return 1
}

ValidateHistory () {
    local content="$1"
    ValidateHistoryField "$content" 'Tag#' || return
    ValidateHistoryField "$content" 'Label#' || return
    ValidateHistoryField "$content" 'Issue#' || return
    ValidateHistoryField "$content" 'Scope' || return
    ValidateHistoryField "$content" 'Severity' || return
    ValidateHistoryField "$content" 'Category' || return
    ValidateHistoryField "$content" 'Symptom' || return
    ValidateHistoryField "$content" 'RootCause' || return
    ValidateHistoryField "$content" 'Solution' || return
    ValidateHistoryField "$content" 'SolutionDependency' || return
}

CheckStage () {
    local option="${1-normal}"
    local -r DIFF=$(git -c "core.safecrlf=false" diff --cached --name-only)
    test "$DIFF" || CheckStage_NoStage || return
    grep -q "\<$TEMPF\>" <<<"$DIFF" || return 0
    CheckStage_HasTemp
}

CheckStage_NoStage () {
    test "$option" = "amend" && return
    >&2 Prompt red \
        "error: There is no staged changes." \
        "Stage changes to be committed with 'git add'."
    return 1
}

CheckStage_HasTemp () {
    test "$option" = "template" && return
    git restore --staged "$TEMPF" >/dev/null
    >&2 Prompt yellow \
"warning: $TEMPF was staged. But was skipped." \
"If you want to modify the template, use command 'inspurcommit template'."
    CheckStage
}

CheckFileAlreadyExists () {
    local filename="$1"
    test ! -e "$filename" && return
    >&2 Prompt red "error: File $filename already exists."
    return 1
}

FindFile () {
    local filename="$1"
    test -e "$filename" && return
    >&2 Prompt red "error: Couldn't find file $filename."
    return 1
}

# Get Field Content
# & $1: variable byref
#   $2: change history content
#   $3: field
GetField () {
    local -n gf_var=$1
    local -r CHC="$2"
    local -r FIELD="$3"
    gf_var=$(grep "^${FIELD}:" <<<"$CHC" | sed "s/^${FIELD}:\s*//")
}

# Set Field Content
# & $1: change history content byref
#   $2: field
#   $3: field content
SetField () {
    local -n chc=$1
    local -r SF_FLD="$2"
    local -r SF_FLDC="$3"
    chc=$(sed "s/^${SF_FLD}:.*$/${SF_FLD}: ${SF_FLDC}/" <<<"$chc")
}

# Filter Out, case insensitive
# & $1: string variable byref
#   $2: filters
FilterOut () {
    local -n str=$1
    local fo_fs="$2"
    local IFS=','
    for fo_f in $fo_fs
    do
        test "${fo_f-}" &&
            str=$(grep -iv "^${fo_f}:" <<<"$str")
    done
}

PushdRoot () {
    git rev-parse || return
    pushd "$(git rev-parse --show-toplevel)"
}

Commit () {
    local summary
    local details
    local filelist
    details=$(grep -v '^#\|^\s*$' "$TMPF")
    ValidateHistory "$details" || return
    GetField summary "$details" "Solution"
    Commit_CheckLastSummary || return
    Commit_CreateRelatedFiles || return
    Commit_IsNotAmend "$@" || return 0
    git commit "$@" -m "$summary" -m "$details"
}

Commit_CheckLastSummary () {
    local last_summary
    test "$OP" = "amend" && return
    last_summary=$(git log -1 --format=%s)
    test "$last_summary" != "$summary" && return
    >&2 Prompt red "error: Solution is same with last one."
    return 1
}

Commit_CreateRelatedFiles () {
    ValidateHistoryField "$details" "RelatedFiles" 2>/dev/null || return 0
    details=$(sed '/^RelatedFiles:/,$d' <<<"$details")
    if test "$OP" = "amend"
    then
        git reset --soft @^ || return
        filelist=$(jgn)
        git reset --soft ORIG_HEAD
    else
        filelist=$(jgn)
    fi
    printf -v details -- "%s\n%s" "$details" "$filelist"
}

Commit_IsNotAmend () {
    local chid
    test "$OP" != "amend" && return
    chid=$(git log -1 --format=%b | grep '^Change-Id:')
    test "${chid-}" || >&2 Prompt y "warning: Failed to get Change-ID."
    git commit "$@" -m "$summary" -m "$details" -m "$chid"
    return 1
}

# Init template with default values set
# local dff: default template file
# local dfc: content of $dff
InitTemplate () {
    local dff
    local dfc
    dff="$(dirname "$0")/$TEMPF"
    FindFile "$dff" || return
    dfc=$(<"$dff")
    test "${df_tag-}" && SetField dfc "Tag#" "$df_tag"
    test "${df_lbl-}" && SetField dfc "Label#" "$df_lbl"
    test "${df_iss-}" && SetField dfc "Issue#" "$df_iss"
    test "${df_scp-}" && SetField dfc "Scope" "$df_scp"
    test "${df_svr-}" && SetField dfc "Severity" "$df_svr"
    test "${df_ctg-}" && SetField dfc "Category" "$df_ctg"
    test "${df_spt-}" && SetField dfc "Symptom" "$df_spt"
    test "${df_rtc-}" && SetField dfc "RootCause" "$df_rtc"
    test "${df_slt-}" && SetField dfc "Solution" "$df_slt"
    test "${df_dpd-}" && SetField dfc "SolutionDependency" "$df_dpd"
    test "${df_rlf-}" && SetField dfc "RelatedFiles" "$df_rlf"
    printf -- "%s\n" "$dfc" >"$TEMPF"
}

GenerateTmp () {
    test -e "$TMPF" && return
    cp "./$TEMPF" "./$TMPF"
    Prompt green "Generated file $TMPF"
    Prompt yellow \
        "Write change history in this file and save, and commit again."
    return 1
}

ShowLogo () {
cat <<LOGO

    inspurcommit v$REVISION
    $AUTHOR

LOGO
}

ShowUsage () {
cat <<SHOWUSG
Usage:
    inspurcommit [<operation>]

Operations:
    amend, clean, diff, export, init, load, merge, purge, push, template

For help on a specific operation:
    inspurcommit <operation> --help

If no operation is specified, it is used to perform a git commit. Here are
the steps:
    1. Use command 'git add <file>', or 'git add .', etc. to stage changes.
    2. Write change history in file $TMPF.
       If this file does not exist, use command 'inspurcommit' to generate
       one, and then write change history in it.
    3. Use command 'inspurcommit' to commit. Arguments, if any, will be
       passed to git commit.
SHOWUSG
}

purgeUsage () {
cat <<EOF
Usage:
    inspurcommit purge

Remove $TMPF and regenerate one.
EOF
}

pushUsage () {
cat <<\PUSHUSG
Usage:
    inspurcommit push [<option>...] [<branch>]

Push local commits to Gerrit. Default <branch> is the current one.
<option>s will be passed to git push.  This command is equivalent to:

    git push [<option>...] origin HEAD:refs/for/<branch>
PUSHUSG
}

amendUsage () {
cat <<AMENDUSG
Usage:
    inspurcommit amend [<option>...]

Amend last commit with current $TMPF and staged changes.
<option>s will be passed to git commit.
AMENDUSG
}

cleanUsage () {
cat <<CLEANUSG
Usage:
    inspurcommit clean

Clean changes of overridden files.
CLEANUSG
}

exportUsage () {
cat <<\EXPORTUSG
Usage:
    inspurcommit export [-a|--all] [{-x|--exclude} <filter>,...]
                        [--] [<filename>]

Export a change history without 'scope' filed, unless '--all' is specified.

If '--exclude' is specified, export a change history with all fields except
<filter>s. Multiple filters can be splitted by ',' as in '-x tag#,scope'.

'--exclude' implies '--all'.
EXPORTUSG
}

templateUsage () {
cat <<\TEMPLATEUSG
Usage:
    inspurcommit template [<option>...]

Normally, changes of the template cannot be committed, in case it is
changed by accident. When you intend to change the template, you can use
this operation. <option>s will be passed to git commit.
TEMPLATEUSG
}

initUsage () {
cat <<\INITUSG
Usage:
    inspurcommit init [<defaults> ...]

Defaults:
    -t, --tag <tag#>
    -l, --label <label#>
    -i, --issue <Issue#>
    -s, --scope <Scope>
    -v, --severity <Severity>
    -c, --category <Category>
    -y, --symptom <Symptom>
    -r, --rootcause <RootCause>
    -o, --solution <Solution>
    -d, --dependency <SolutionDependency>
    -f, --files <RelatedFiles>

Example:
    inspurcommit init -t "5.19_CedarIslandCrb_0ACMT_013"
INITUSG
}

loadUsage () {
cat <<EOF
Usage:
    inspurcommit load [<commit-id>]

Load messages to $TMPF from specific <commit-id>.
If <commit-id> is not specified, load from current commit.
EOF
}

diffUsage () {
cat <<\DIFFUSG
Usage:
    inspurcommit diff [<option>...]

Diff with Beyond Compare. <option>s will be passed to git difftool.
Try 'git difftool --help' for more information.

If you want to diff the staged changes, use 'inspurcommit diff --cached'.
DIFFUSG
}

mergeUsage () {
cat <<\MERGEUSG
Usage:
    inspurcommit merge [<file to merge> ...]

Resolve merge conflicts with Beyond Compare. If <file to merge> is not
specified, resolve all conflicted files one by one.
MERGEUSG
}

LookupUsage () {
    local -r OPERATION="$1"
    local argument
    test "$#" -le 1 && return
    argument="$2"
    if test "$argument" = "-?" ||
        test "$argument" = "-h" ||
        test "$argument" = "--help" ||
        test "$argument" = "--usage"
    then
        ${OPERATION}Usage
        return 1
    fi
    return 0
}

mainUsage () {
    ShowLogo
    ShowUsage
}

err () {
    local -r red="[91m"
    local -r rst="[0m"
    local msg="${1-unspecific error}"
    >&2 printf -- "${red}error: %s${rst}\n" "$msg"
    exit 1
}

# Prompt
# $1:   color, red/yellow/green
# ...:  content lines
Prompt () {
    local -r RED="[91m"
    local -r GRN="[92m"
    local -r YLW="[93m"
    local -r RST="[0m"
    local -r COLOR_ARG="$1"
    local color
    shift
    case "$COLOR_ARG" in
    r|red)
        color="$RED"
        ;;
    g|grn|green)
        color="$GRN"
        ;;
    y|ylw|yellow)
        color="$YLW"
        ;;
    *)
        >&2 Prompt red "error: unknown color argument: $COLOR_ARG"
        return 1
        ;;
    esac
    printf -- "${color}%s${RST}\n" "$@"
}

commitOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage || return
    Commit "$@"
}

pushOp () {
    local p_br
    local br_d
    local sws
    while test $# -ge 1
    do
        case "${p_br-},$1" in
        *,-*)
            sws="${sws-} $1"
            shift
            ;;
        '',*)
            p_br="$1"
            shift
            ;;
        *)
            err "invalid argument: $1"
            ;;
        esac
    done
    git rev-parse || return
    br_d=$(git rev-parse --abbrev-ref HEAD) || return
    git push ${sws-} origin HEAD:refs/for/"${p_br-$br_d}"
}

diffOp () {
    local bc=
    git rev-parse || return
    diffOp_GetBeyondCompare || return
    git -c "diff.tool=BeyondCompare" \
        -c "difftool.BeyondCompare.cmd=\"$bc\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\"" \
        difftool --dir-diff "$@"
}

mergeOp () {
    local bc=
    git rev-parse || return
    diffOp_GetBeyondCompare || return
    git -c "merge.tool=BeyondCompare" \
        -c "mergetool.BeyondCompare.cmd=\"$bc\" \"\$(cygpath -w \"\$LOCAL\")\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\"" \
        -c "mergetool.BeyondCompare.trustExitCode=true" \
        mergetool "$@"
}

diffOp_GetBeyondCompare () {
    local -r bc_reg_p='HKCU\Software\Scooter Software\Beyond Compare'
    local -r bc_reg_k="ExePath"
    test "$JG_BC_PATH" && bc=$JG_BC_PATH && return
    if ! grep -Gqi '^win' <<<"$OS"
    then
        >&2 Prompt yellow "Sorry, this operation is Windows only for now."
        return 1
    fi
    bc=$(reg query "$bc_reg_p" //v "$bc_reg_k" 2>/dev/null)
    if test ! "$bc"
    then
        >&2 Prompt red "error: Couldn't find Beyond Compare." \
            "Please defined the path to bcompare.exe in JG_BC_PATH and restart shell."
        return 1
    fi
    bc=$(grep "ExePath" <<<"$bc" | sed 's/\s\{4\}.*\s\{4\}//')
}

amendOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage amend || return
    Commit --amend "$@"
}

cleanOp () {
    local st fl md nw tor toc
    PushdRoot || return
    fl=$(grep -rho --include=*.cif ';\s*"[^"]\+[^" ]' . |
        sed -e 's/^;\s*"//' \
            -e 's/\\/\//g' |
        sort -u)
    st=$(git status --porcelain)
    tor=$(comm -12 - <<<"$fl" <(sed -n '/^ M /{s/^ M //p}' <<<"$st" | sort))
    toc=$(comm -12 - <<<"$fl" <(sed -n '/^?? /{s/^?? //p}' <<<"$st" | sort))
    test "${tor-}" && xargs <<<"$tor" -d '\n' git restore --
    test "${toc-}" && xargs <<<"$toc" -d '\n' git clean -qf --
    return 0
}

# Operation: Export a Change History
# $0 export [-a|--all] [{-x|--exclude} <field>] [[--] <filename>]
# <filename>: Use "ChangeHistory[-All]-%h" if not specified.
# $fci: hash of the parent of INSPURCOMMIT-INIT
# $fcic: hash of INSPURCOMMIT-INIT
exportOp () {
    local fltrs
    local chfn
    local fcic
    local ch_c
    local empty
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    exportOp_Parse "$@" || return
    exportOp_GetFcic || return
    exportOp_GetContent || return
    exportOp_SetFileName
    exportOp_Write
}

exportOp_Parse_Again () {
    local mode="$1" eff eqeff eqval flag
    shift
    sn=1
    case "$mode" in
    no)
        eff="${1#--no-}"
        ;;
    2)
        eff="${1#--}"
        ;;
    1)
        eff="${1#-}"
        ;;
    *)
        err "unknown mode: $mode"
        ;;
    esac
    case "$eff,$mode" in
    all,no)
        err "invalid switch '--no-all'"
        ;;
    all,2)
        test "${fltrs+set}" || fltrs=""
        ;;
    exclude,no)
        fltrs=""
        ;;
    exclude,2)
        test "${2-}" || err "switch '$eff' requires a value"
        fltrs="${fltrs-},$2"
        sn=2
        ;;
    exclude=*,2)
        eqeff="${eff%%=*}"
        eqval="${eff#$eqeff=}"
        test "$eqval" || err "switch '$eqeff' requires a value"
        fltrs="${fltrs-},${eqval}"
        ;;
    *,1)
        while test ${#eff} -ge 1
        do
            flag="${eff:0:1}"
            eff="${eff#?}"
            case $flag in
            a)
                fltrs=""
                ;;
            x)
                if test "$eff"
                then
                    fltrs="${fltrs-},$eff"
                    eff=""
                elif test "${2-}"
                then
                    fltrs="${fltrs-},$2"
                    sn=2
                else
                    err "switch '$flag' requires a value"
                fi
                ;;
            *)
                err "invalid switch: $flag"
                ;;
            esac
        done
        ;;
    *)
        err "invalid switch: $eff"
        ;;
    esac
}

exportOp_Parse () {
    local -i sn=1
    while test "$#" -gt 0
    do
        case "$1" in
        --)
            shift
            break
            ;;
        --no-*)
            exportOp_Parse_Again "no" "$@"
            shift $sn
            ;;
        --*)
            exportOp_Parse_Again "2" "$@"
            shift $sn
            ;;
        -*)
            exportOp_Parse_Again "1" "$@"
            shift $sn
            ;;
        *)
            test "${chfn-}" && err "invalid argument: $1"
            chfn="$1"
            shift
            ;;
        esac
    done
    case "${chfn-},$#" in
    *,0)
        ;;
    ,1)
        chfn="$1"
        ;;
    *)
        err "too many arguments"
        ;;
    esac
    test "${fltrs+set}" || fltrs="Scope"
}

exportOp_GetFcic () {
    local fci
    FindFile "$FCIF" || return
    fci=$(<"$FCIF")
    fcic=$(git rev-list --reverse "$fci".. | head -1)
}

# b_wo_chid: commit body without change-ID
exportOp_GetContent () {
    local b_wo_chid
    b_wo_chid=$(git log --format=%b --no-merges "$fcic".. |
        sed '/^Change-Id:\s\w\{41\}$/,+1d')
    FilterOut b_wo_chid "$fltrs"
    ch_c="$b_wo_chid"
    if test "${ch_c-}"
    then
        empty=no
    else
        empty=empty
    fi
}

exportOp_SetFileName () {
    local curr_h
    test "${chfn-}" && return
    curr_h=$(git log -1 --format=%h)
    chfn="ChangeHistory-${curr_h}.txt"
}

exportOp_Write () {
    CheckFileAlreadyExists "$chfn" || return
    test "$empty" != "empty" && printf -- "%s\n" "$ch_c" >"$chfn"
    if ! exportOp_Write_Cat && test "$empty" = "empty"
    then
        >&2 Prompt red "error: Nothing to export."
        return 1
    fi
    Prompt green "Exported file $chfn"
}

exportOp_Write_Cat () {
    local oldc
    test -e "$OLDF" || return
    d2u "$OLDF" 2>/dev/null || >&2 Prompt yellow "warning: D2U failed."
    oldc=$(<"$OLDF")
    FilterOut oldc "$fltrs"
    if test "$empty" = "empty"
    then
        printf -- "%s\n" "$oldc" >"$chfn"
    else
        printf -- "\n%s\n" "$oldc" >>"$chfn"
    fi
}

templateOp () {
    git rev-parse || return
    CheckInit || return
    PushdRoot || return
    GenerateTmp || return 0
    CheckStage template || return
    Commit "$@"
}

initOp () {
    local df_tag
    local df_lbl
    local df_iss
    local df_scp
    local df_svr
    local df_ctg
    local df_spt
    local df_rtc
    local df_slt
    local df_dpd
    local df_rlf
    git rev-parse || return
    PushdRoot || return
    initOp_CheckInit || return
    initOp_CheckGitIgnore || return
    initOp_CheckStage || return
    initOp_Parse "$@" || return
    initOp_RenameTmp && initOp_Start && return
    initOp_CleanUp
    return 1
}

initOp_CheckInit () {
    CheckInit 2>/dev/null || return 0
    >&2 Prompt red "error: This repository has already been initialized."
    return 1
}

initOp_CheckGitIgnore () {
    git status --porcelain | grep -q '\<.gitignore\>' || return 0
    >&2 Prompt red \
"error: Please commit or stash your local changes of file '.gitignore'" \
"before init."
    return 1
}

initOp_CheckStage () {
    CheckStage 2>/dev/null || return 0
    >&2 Prompt red \
        "error: Please commit or stash your staged changes before init."
    >&2 git status
    return 1
}

initOp_Parse () {
    local -i sn
    while test "$#" -gt 0
    do
        case $1 in
        --no-*)
            initOp_Parse_Again no "$@"
            shift $sn
            ;;
        --*)
            initOp_Parse_Again 2 "$@"
            shift $sn
            ;;
        -*)
            initOp_Parse_Again 1 "$@"
            shift $sn
            ;;
        *)
            ;;
        esac
    done
}

initOp_Parse_Again () {
    local mode="$1" eff
    shift
    sn=2
    case $mode in
    no)
        sn=1
        eff="${1#--no-}"
        initOp_ParseNo "$@"
        ;;
    2)
        eff="${1#--}"
        initOp_Parse2 "$@"
        ;;
    1)
        eff="${1#-}"
        initOp_Parse1 "$@"
        ;;
    *)
        err "unknown mode: $mode"
        ;;
    esac
}

initOp_ParseNo () {
    case $eff in
    tag)
        df_tag=''
        ;;
    label)
        df_lbl=''
        ;;
    issue)
        df_iss=''
        ;;
    scope)
        df_scp=''
        ;;
    severity)
        df_svr=''
        ;;
    category)
        df_ctg=''
        ;;
    symptom)
        df_spt=''
        ;;
    rootcause)
        df_rtc=''
        ;;
    solution)
        df_slt=''
        ;;
    dependency|solution-dependency)
        df_dpd=''
        ;;
    files|related-files)
        df_rlf=''
        ;;
    *)
        err "invalid switch: no-$eff"
        ;;
    esac
}

initOp_Parse2 () {
    val=${2-}
    case $eff in
    tag)
        test "$val" || err "switch '$eff' requires a value"
        df_tag=$val
        ;;
    tag=*)
        sn=1
        val=${eff#tag=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_tag=$val
        ;;
    label)
        test "$val" || err "switch '$eff' requires a value"
        df_lbl=$val
        ;;
    label=*)
        sn=1
        val=${eff#label=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_lbl=$val
        ;;
    issue)
        test "$val" || err "switch '$eff' requires a value"
        df_iss=$val
        ;;
    issue=*)
        sn=1
        val=${eff#issue=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_iss=$val
        ;;
    scope)
        test "$val" || err "switch '$eff' requires a value"
        df_scp=$val
        ;;
    scope=*)
        sn=1
        val=${eff#scope=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_scp=$val
        ;;
    severity)
        test "$val" || err "switch '$eff' requires a value"
        df_svr=$val
        ;;
    severity=*)
        sn=1
        val=${eff#severity=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_svr=$val
        ;;
    category)
        test "$val" || err "switch '$eff' requires a value"
        df_ctg=$val
        ;;
    category=*)
        sn=1
        val=${eff#category=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_ctg=$val
        ;;
    symptom)
        test "$val" || err "switch '$eff' requires a value"
        df_spt=$val
        ;;
    symptom=*)
        sn=1
        val=${eff#symptom=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_spt=$val
        ;;
    rootcause)
        test "$val" || err "switch '$eff' requires a value"
        df_rtc=$val
        ;;
    rootcause=*)
        sn=1
        val=${eff#rootcause=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_rtc=$val
        ;;
    solution)
        test "$val" || err "switch '$eff' requires a value"
        df_spt=$val
        ;;
    solution=*)
        sn=1
        val=${eff#solution=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_spt=$val
        ;;
    dependency|solution-dependency)
        test "$val" || err "switch '$eff' requires a value"
        df_dpd=$val
        ;;
    dependency=*)
        sn=1
        val=${eff#dependency=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_dpd=$val
        ;;
    solution-dependency=*)
        sn=1
        val=${eff#solution-dependency=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_dpd=$val
        ;;
    files|related-files)
        test "$val" || err "switch '$eff' requires a value"
        df_rlf=$val
        ;;
    files=*)
        sn=1
        val=${eff#files=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_rlf=$val
        ;;
    related-files=*)
        sn=1
        val=${eff#related-files=}
        eff=${eff%=$val}
        test "$val" || err "switch '$eff' requires a value"
        df_rlf=$val
        ;;
    *)
        err "invalid switch: $eff"
        ;;
    esac
}

initOp_Parse1 () {
    local sw val
    if test ${#eff} -gt 1
    then
        sn=1
        sw=${eff:0:1}
        val=${eff#?}
    elif test ${2-}
    then
        sw=$eff
        val=$2
    else
        err "switch '$sw' requires a value"
    fi
    case $sw in
    t)
        df_tag=$val
        ;;
    l)
        df_lbl=$val
        ;;
    i)
        df_iss=$val
        ;;
    s)
        df_scp=$val
        ;;
    v)
        df_svr=$val
        ;;
    c)
        df_ctg=$val
        ;;
    y)
        df_spt=$val
        ;;
    r)
        df_rtc=$val
        ;;
    o)
        df_slt=$val
        ;;
    d)
        df_dpd=$val
        ;;
    f)
        df_rlf=$val
        ;;
    *)
        err "invalid switch: $sw"
        ;;
    esac
}

initOp_CleanUp () {
    initOp_CleanUp_IsCommited && git reset @^ 1>/dev/null
    test -e "$OLDF" &&
        git clean -qfX -- "$TMPF" 1>/dev/null &&
        test ! -e "$TMPF" &&
        mv "$OLDF" "$TMPF"
    git restore --staged .
    test -e "$TEMPF" && rm "$TEMPF"
    test -e "$FCIF" && rm "$FCIF"
    git clean -qf -- .gitignore
    test -e .gitignore && git checkout -- .gitignore
}

initOp_CleanUp_IsCommited () {
    local fci
    local revlist
    local cid
    local pre_cid
    test -e "$FCIF" || return
    fci=$(<"$FCIF")
    revlist=$(git rev-list @)
    cid=$(head -1 <<<"$revlist")
    test "$fci" != "$cid" || return
    pre_cid=$(head -2 <<<"$revlist" | tail -1)
    test "$fci" = "$pre_cid" && return
    >&2 Prompt yellow \
        "warning: Failed to get current state when cleaning up."
    return 1
}

initOp_RenameTmp () {
    test ! -e "$TMPF" && return
    CheckFileAlreadyExists "$OLDF" || return
    d2u "$TMPF" 2>/dev/null || return
    mv "$TMPF" "$OLDF" || return
    git -c "core.safecrlf=false" add "$TMPF" "$OLDF" || return
}

initOp_Start () {
    local init_title="INSPURCOMMIT-INIT"
    local init_msg
    git log --format="%H" -1 1>"$FCIF" || return
    InitTemplate || return
    printf -- "%s\n" "/$TMPF" "/ChangeHistory-*.txt">>.gitignore || return
    git -c "core.safecrlf=false" add "$TEMPF" "$FCIF" .gitignore || return
    printf -v init_msg -- "%s\n" \
"This commit was automatically generated to initialize this repository in"\
"order to use Inspur Commit Kit." || return
    git commit -m "$init_title" -m "$init_msg" 1>/dev/null || return
    Prompt green "Initialization completed successfully."
}

purgeOp () {
    test $# -eq 0 || err "too many arguments"
    PushdRoot || return
    if test -e "$TMPF"
    then
        rm "$TMPF" || return
    fi
    GenerateTmp 1>/dev/null || return 0
}

loadOp () {
    local id msg
    test $# -le 1 || err "too many arguments"
    id=$(git rev-parse "${1-HEAD}") || return
    PushdRoot || return
    msg=$(git show -s --format=%b "$id" | sed '/^RelatedFiles:/,$d')
    test "$msg" || err "got an empty result from $id; is it a merge?"
    printf "%s\n" "$msg" "$(grep '^RelatedFiles:' "$TEMPF")" >"$TMPF"
}

main () {
    local -r REVISION="0.12.1"
    local -r AUTHOR="Johnny Appleseed <liuzhaohui@inspur.com>"
    local -r TEMPF="$template_file_name"
    local -r TMPF="$change_history_name"
    local -r OLDF="$old_change_history_name"
    local -r FCIF="$fci_file_name"
    local -r OP="${1-}"
    local -r JG_BC_PATH=${JG_BC_PATH-}
    local -r OS=${OS-}
    LookupUsage "main" "$@" || exit 0
    case "$OP" in
    amend|clean|diff|export|init|load|merge|purge|push|template)
        shift
        ;;
    --version)
        ShowLogo
        exit
        ;;
    ''|-*)
        commitOp "$@"
        return
        ;;
    *)
        >&2 Prompt red "error: invalid argument: $OP" \
            "Try 'inspurcommit --help' for help."
        exit 1
        ;;
    esac
    LookupUsage "$OP" "$@" || return 0
    ${OP}Op "$@"
}

main "$@"
